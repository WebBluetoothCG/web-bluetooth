<!DOCTYPE html>
<html>
  <head>
    <title>Web Bluetooth</title>
    <meta charset='utf-8'>
    <script src='https://www.w3.org/Tools/respec/respec-w3c-common'
            async class='remove'></script>
    <script class='remove'>
      var respecConfig = {
          specStatus: "CG-DRAFT",
          shortName:  "web-bluetooth",
          editors: [
            { name: "See contributors on GitHub",
              url: "https://github.com/WebBluetoothCG/web-bluetooth/graphs/contributors"
            },
          ],
          edDraftURI:   "http://webbluetoothcg.github.io/web-bluetooth/",
          wg:           "Web Bluetooth Community Group",
          wgURI:        "https://www.w3.org/community/web-bluetooth/",
          wgPublicList: "public-web-bluetooth",
          wgPatentURI:  "https://www.w3.org/2004/01/pp-impl/72794/status",
          noLegacyStyle: true,

          otherLinks: [{
            key: "Participate",
            data: [
              { value: "Join the W3C Community Group",
                href: "http://www.w3.org/community/web-bluetooth/",
              },
              { value: "File bugs and feature requests",
                href: "https://github.com/WebBluetoothCG/web-bluetooth/issues",
              },
              { value: "Fix the text through GitHub",
                href: "https://github.com/WebBluetoothCG/web-bluetooth",
              },
              { value: "IRC: #web-bluetooth on W3C's IRC",
                href: "irc://irc.w3.org:6665/#web-bluetooth",
              },
              { value: "Public Mailing List",
                href: "http://lists.w3.org/Archives/Public/public-web-bluetooth/",
              },
            ],
          }],

          localBiblio: {
            "BLUETOOTH42": {
              href: "https://www.bluetooth.org/DocMan/handlers/DownloadDoc.ashx?doc_id=286439",
              title: "BLUETOOTH SPECIFICATION Version 4.2",
              publisher: "Bluetooth SIG",
              date: "2 December 2014",
            },
            "BLUETOOTH-GATT-REST": {
              href: "https://www.bluetooth.org/docman/handlers/downloaddoc.ashx?doc_id=285910",
              title: "GATT REST API",
              publisher: "Bluetooth Internet WG",
              date: "7 April 2014",
            },
            "BLUETOOTH-ASSIGNED": {
              href: "https://www.bluetooth.org/en-us/specification/assigned-numbers",
              title: "Assigned Numbers",
              status: "Living Standard",
              publisher: "Bluetooth SIG",
            },
            "BLUETOOTH-ASSIGNED-BASEBAND": {
              href: "https://www.bluetooth.org/en-us/specification/assigned-numbers/baseband",
              title: "Assigned Numbers for Baseband",
              status: "Living Standard",
              publisher: "Bluetooth SIG",
            },
            "BLUETOOTH-NUMBERS-SERVICES": {
              href: "https://developer.bluetooth.org/gatt/services/Pages/ServicesHome.aspx",
              title: "Bluetooth GATT Specifications > Services",
              status: "Living Standard",
              publisher: "Bluetooth SIG",
            },
            "BLUETOOTH-NUMBERS-CHARACTERISTICS": {
              href: "https://developer.bluetooth.org/gatt/characteristics/Pages/CharacteristicsHome.aspx",
              title: "Bluetooth GATT Specifications > Characteristics",
              status: "Living Standard",
              publisher: "Bluetooth SIG",
            },
            "BLUETOOTH-NUMBERS-DESCRIPTORS": {
              href: "https://developer.bluetooth.org/gatt/descriptors/Pages/DescriptorsHomePage.aspx",
              title: "Bluetooth GATT Specifications > Descriptors",
              status: "Living Standard",
              publisher: "Bluetooth SIG",
            },
            "BLUETOOTH-SUPPLEMENT5": {
              href: "https://www.bluetooth.org/DocMan/handlers/DownloadDoc.ashx?doc_id=291904",
              title: "Supplement to the Bluetooth Core Specification Version 5",
              date: "2 December 2014",
              publisher: "Bluetooth SIG",
            },
          },
      };
    </script>
  </head>
  <body>
    <section id='abstract'>
      <p>
        This document describes an API to discover and communicate with devices over the Bluetooth 4 wireless standard using the Generic Attribute Profile (GATT).
      </p>
    </section>

    <section id='sotd'>
      <p>
        Changes to this document may be tracked at <a href="https://github.com/WebBluetoothCG/web-bluetooth/commits/gh-pages">https://github.com/WebBluetoothCG/web-bluetooth/commits/gh-pages</a>.
      </p>
    </section>

    <section class='informative'>
      <h2>Introduction</h2>
      <p>
        <a href="https://developer.bluetooth.org/">Bluetooth</a> is
        a standard for short-range wireless communication between devices.
        Bluetooth "Classic" (<abbr title="Basic Rate">BR</abbr>/<abbr title="Enhanced Data Rate">EDR</abbr>)
        defines a set of binary protocols and supports speeds up to about 24Mbps.
        Bluetooth 4.0 introduced a new "Low Energy" mode known as "Bluetooth Smart",
        <abbr title="Bluetooth Low Energy">BTLE</abbr>, or just <abbr title="Low Energy">LE</abbr>
        which is limited to about 1Mbps but
        allows devices to leave their transmitters off most of the time.
        BTLE provides most of its functionality through key/value pairs provided by
        the <a title="Generic Attribute Profile">Generic Attribute Profile
        (<abbr title="Generic Attribute Profile">GATT</abbr>)</a>.

      <p>
        BTLE defines multiple roles that devices can play.
        The <dfn>Broadcaster</dfn> and <dfn>Observer</dfn> roles are
        for transmitter- and receiver-only applications, respectively.
        Devices acting in the <dfn>Peripheral</dfn> role can receive connections,
        and devices acting in the <dfn>Central</dfn> role can connect to <a>Peripheral</a> devices.
      </p>

      <p>
        <dfn>GATT</dfn> further defines <dfn>Client</dfn> and <dfn>Server</dfn> roles,
        which are orthogonal to the <a>Peripheral</a> and <a>Central</a> BTLE roles.
        GATT allows <a>Server</a>s to expose <a>Service</a>s, whose type is identified by
        a <abbr title="Universally Unique Identifier">UUID</abbr> ([[!RFC4122]]).
        A <dfn>Service</dfn> exposes a collection of included Services and Characteristics.
        Each <dfn>Characteristic</dfn> has a type named by a UUID and
        exposes a value as an array of bytes,
        some properties to describe how the value can be used, and a collection of Descriptors.
        Each <dfn>Descriptor</dfn> has a type named by a UUID and
        contains related information about the Characteristic Value.

      <p>
        Despite being designed to support BTLE transport,
        the GATT protocol can also run over BR/EDR transport.
        Both support advertising GATT services without a connection:
        BTLE through advertising packets, and BR/EDR through the extended inquiry response.

      <p>
        The first version of this specification focuses on the Bluetooth 4 GATT protocol
        in the <a>Central</a> and <a>Client</a> roles, over either a BR/EDR or LE connection.
        While this specification cites the [[BLUETOOTH42]] specification,
        it intends to also support communication
        with devices that only implement Bluetooth 4.0 or 4.1.
      </p>
    </section>

    <section>
      <h2>Security and privacy considerations</h2>

      <section>
        <h2>Device access is powerful</h2>

        <p>
          When a website requests access to devices using
          <code><a for="Bluetooth">requestDevice</a></code>,
          it gets the ability to access all GATT services mentioned in the call.
          The UA MUST inform the user what capabilities these services give the website
          before asking which devices to entrust to it.
          If any services in the list aren't known to the UA,
          the UA MUST assume they give the site complete control over the device
          and inform the user of this risk.
          The UA MUST also allow the user to inspect what sites have access to what devices
          and revoke these pairings.

        <p>
          The UA MUST NOT allow the user to pair entire classes of devices with a website.
          It is possible to construct a class of devices
          for which each individual device sends the same Bluetooth-level identifying information.
          UAs are not required to attempt to detect this sort of forgery
          and MAY let a user pair this pseudo-device with a website.

        <p>
          To help ensure that only the entity the user approved for access actually has access,
          this specification requires that only <a>sufficiently secure context</a>s
          can access Bluetooth devices
          (<a href="#requestDevice-secure-context">requestDevice</a>).
      </section>

      <section class="informative">
        <h2>Attacks on devices</h2>

        <p>
          We expect that many devices are vulnerable to unexpected data delivered to their radio.
          In the past, these devices had to be exploited one-by-one,
          but this API makes it plausible to conduct large-scale attacks.
          This specification takes several approaches to make such attacks more difficult:

        <ul>
          <li>
            Pairing individual devices instead of device classes
            requires at least a user action before a device can be exploited.

          <li>
            Constraining access to <a>GATT</a>, as opposed to generic byte-stream access,
            denies malicious websites access to most parsers on the device.

            <p>
              On the other hand,
              GATT's <a>Characteristic</a> and <a>Descriptor</a> values are still byte arrays,
              which may be set to lengths and formats the device doesn't expect.
              UAs are encouraged to validate these values when they can.

          <li>
            This API never exposes Bluetooth addressing, data signing or encryption keys
            (<a>Definition of Keys and Values</a>) to websites.
            This makes it more difficult for a website to predict the bits that will be sent over the radio,
            which blocks <a href="https://www.usenix.org/legacy/events/woot11/tech/final_files/Goodspeed.pdf">packet-in-packet injection attacks</a>.
            Unfortunately, this only works over encrypted links,
            which not all BTLE devices are required to support.
        </ul>

        <p>
          UAs can also take further steps to protect their users:

        <ul>
          <li>
            A web service may collect lists of malicious websites and vulnerable devices.
            UAs can deny malicious websites access to any device
            and any website access to vulnerable devices.
        </ul>
      </section>

      <section class="informative">
        <h2>Bluetooth device identifiers</h2>

        <p>
          Each Bluetooth BR/EDR device has a unique 48-bit MAC address
          known as the <a>BD_ADDR</a>.
          Each Bluetooth LE device has at least one of a <a>Public Device Address</a>
          and a <a>Static Device Address</a>.
          The <a>Public Device Address</a> is a MAC address.
          The <a>Static Device Address</a> may be regenerated on each restart.
          A BR/EDR/LE device will use the same value
          for the <a>BD_ADDR</a> and the <a>Public Device Address</a>
          (specified in the <a>Read BD_ADDR Command</a>).
        </p>
        <p>
          An LE device may also have a unique, 128-bit <a>Identity Resolving Key</a>,
          which is sent to trusted devices during the bonding process.
          To avoid leaking a persistent identifier, an LE device may scan and advertise using
          a random Resolvable or Non-Resolvable <a>Private Address</a>
          instead of its Static or Public Address.
          These are regenerated periodically (approximately every 15 minutes),
          but a bonded device can check whether one of its stored <a>IRK</a>s matches
          any given Resolvable Private Address
          using the <a>Resolvable Private Address Resolution Procedure</a>.
        </p>
        <p>
          Each Bluetooth device also has a human-readable <a>Bluetooth Device Name</a>.
          These aren't guaranteed to be unique, but may well be, depending on the device type.

        <section class="informative">
          <h2>Identifiers for remote Bluetooth devices</h2>

          <p>
            If a website can retrieve any of the persistent device IDs,
            these can be used, in combination with a large effort to catalog ambient devices,
            to discover a user's location.
            A device ID can also be used to identify that a user who
            pairs two different websites with the same Bluetooth device
            is a single user.
            On the other hand, many GATT services are available
            that could be used to fingerprint a device,
            and a device can easily expose a custom GATT service to make this easier.

          <p>
            Because it would be so easy to work around an attempt to block device identification,
            this spec doesn't try to do so.
        </section>

        <section class="informative">
          <h2>The UA's Bluetooth address</h2>

          <p>
            In BR/EDR mode, or in LE mode during active scanning without the <a>Privacy Feature</a>,
            the UA broadcasts its persistent ID to any nearby Bluetooth radio.
            This makes it easy to scatter hostile devices in an area and track the UA.
            As of 2014-08, few or no platforms document that they implement the <a>Privacy Feature</a>,
            so despite this spec recommending it, few UAs are likely to use it.
            This spec does <a href="#requestDevice-user-gesture">require a user gesture</a>
            for a website to trigger a scan, which reduces the frequency of scans some,
            but it would still be better for more platforms to expose the <a>Privacy Feature</a>.
        </section>
      </section>
    </section>

    <section>
      <h2>Device Discovery</h2>

      <pre class="idl">
        dictionary BluetoothScanFilter {
          sequence&lt;BluetoothServiceUUID> services;
        };

        dictionary RequestDeviceOptions {
          sequence&lt;BluetoothServiceUUID> optionalServices = [];
        };

        [NoInterfaceObject]
        interface Bluetooth {
          Promise&lt;BluetoothDevice> requestDevice(
            sequence&lt;BluetoothScanFilter> filters,
            optional RequestDeviceOptions options);
        };
      </pre>
      <div class="note" title="Bluetooth members">
        <p>
          <code><a for="Bluetooth">requestDevice</a>(filters, options)</code> asks the user
          to grant this origin access to a device
          that <a>matches a filter</a> in <code>filters</code>.
          The user will be shown devices that support
          <em>all</em> the GATT service UUIDs in the <dfn for="BluetoothScanFilter">services</dfn> list
          of <em>any</em> <a>BluetoothScanFilter</a> in <code>filters</code>.
        </p>
        <p>
          After the user selects a device to pair with this origin,
          the origin is allowed to access to any service whose UUID was listed
          in the <a for="BluetoothScanFilter">services</a> list
          in any element of <code>filters</code>
          or in <code>options.<dfn for="RequestDeviceOptions">optionalServices</dfn></code>.
        </p>
        <p>
          More <a>Bluetooth</a> members are defined in <a href="#object-and-uuid-lookup"></a>.
        </p>
      </div>

      <aside class="example">
        <p>
          Say the UA is close to the following devices:
        </p>
        <table>
          <tr><th>Device</th><th>Advertised Services</th></tr>
          <tr><td>D1</td><td>A, B, C, D</td></tr>
          <tr><td>D2</td><td>A, B, E</td></tr>
          <tr><td>D3</td><td>C, D</td></tr>
          <tr><td>D4</td><td>E</td></tr>
        </table>
        <p>
          If the website calls
        </p>
        <pre class="highlight">navigator.bluetooth.requestDevice(
  [ {services: [A, B]} ])</pre>
        <p>
          the user will be shown a dialog containing devices D1 and D2.
          If the user selects D1, the website will not be able to access services C or D.
          If the user selects D2, the website will not be able to access service E.
        </p>
        <p>
          On the other hand, if the website calls
        </p>
        <pre class="highlight">navigator.bluetooth.requestDevice(
  [
    {services: [A, B]},
    {services: [C, D]}
  ])</pre>
        <p>
          the dialog will contain devices D1, D2, and D3,
          and if the user selects D1,
          the website will be able to access services A, B, C, and D.
        </p>
        <p>
          The <code>optionalServices</code> list doesn't add any devices
          to the dialog the user sees,
          but it does affect which services the website can use from the device the user picks.
        </p>
        <pre class="highlight">navigator.bluetooth.requestDevice(
  [ {services: [A, B]} ],
  {optionalServices: [E]})</pre>
        <p>
          Shows a dialog containing D1 and D2,
          but not D4, since D4 doesn't contain the required services.
          If the user selects D2, unlike in the first example,
          the website will be able to access services A, B, and E.
        </p>
        <p>
          The allowed services also apply if the device changes after the user grants access.
          For example, if the user selects D1 in the previous <code>requestDevice()</code> call,
          and D1 later adds a new E service,
          that will fire the <code><a>serviceadded</a></code> event,
          and the web page will be able to access service E.
        </p>
      </aside>

      <p>
        A device <dfn>matches a filter</dfn> <var>filter</var> if
      </p>
      <ul>
        <li><code><var>filter</var>.services</code> is not empty and</li>
        <li>
          the UA has received advertising data, an <a>extended inquiry response</a>,
          or a service discovery response indicating that
          the device supports each of the <a>Service</a> UUIDs
          included in <code><var>filter</var>.services</code> as a primary (vs included) service.
        </li>
      </ul>

      <p class="note">
        The list of Service UUIDs that a device advertises
        might not include all the UUIDs the device supports.
        The advertising data does specify whether this list is complete.
        If a website filters for a UUID that a nearby device supports but doesn't advertise,
        that device might not be included in the list of devices presented to the user.
        The UA would need to connect to the device to discover the full list of supported services,
        which can impair radio performance and cause delays, so this spec doesn't require it.
      </p>

      <p dfn-for="Bluetooth">
        The <code><dfn>requestDevice</dfn>(<var>filters</var>, <var>options</var>)</code> method,
        when invoked, MUST return <a>a new promise</a> <var>promise</var>
        and run the following steps <a>in parallel</a>:
      </p>
      <ol>
        <li id="requestDevice-secure-context">
          If the <a>incumbent settings object</a> is not a <a>sufficiently secure context</a>,
          <a>reject</a> <var>promise</var> with a <a>SecurityError</a> and abort these steps.
        </li>
        <li id="requestDevice-user-gesture">
          If the algorithm is not <a>allowed to show a popup</a>,
          <a>reject</a> <var>promise</var> with a <a>SecurityError</a> and abort these steps.
        </li>
        <li>
          <a>Scan for devices</a> with
          the union of all <code>services</code> sequences in <code><var>filters</var></code>
          as the <var>set of <a>Service</a> UUIDs</var>,
          and let <var>scanResult</var> be the result.
        </li>
        <li>
          Remove devices from <var>scanResult</var> if
          they do not <a title="matches a filter">match a filter</a>
          in <code><var>filters</var></code>.
        </li>
        <li>
          Even if <var>scanResult</var> is empty,
          display a prompt to the user requesting that the user select a device from it.
          The UA SHOULD show the user the human-readable name of each device.
          If this name is not available because the UA's Bluetooth system doesn't support privacy-enabled scans,
          the UA SHOULD allow the user to indicate interest and then perform a privacy-disabled scan to retrieve the name.
          <p>
            The UA MAY allow the user to select a nearby device
            that does not match <code><var>filters</var></code>.
          </p>
        </li>
        <li>
          Wait for the user to have selected a <var>device</var> or cancelled the prompt.
        </li>
        <li>
          If the user cancels the prompt,
          <a>reject</a> <var>promise</var> with a <a>NotFoundError</a> and abort these steps.
        </li>
        <li>
          <a title="add an allowed bluetooth device"
             >Add <var>device</var> to the origin's allowed devices map.</a>
          with the union of the service UUIDs from <code><var>filters</var></code>
          and <code>options.optionalServices</code> as <var>allowed services</var>.
        </li>
        <li>
          <a>Get the <code>BluetoothDevice</code> representing</a> <var>device</var>
          and <a>resolve</a> <var>promise</var> with the result.
        </li>
      </ol>

      <p>
        To <dfn>scan for devices</dfn> with
        an optional <var>set of <a>Service</a> UUIDs</var>, defaulting to the set of all UUIDs,
        the UA MUST perform the following steps:

      <ol>
        <li>
          If the UA has scanned for devices recently
          <span class="issue">TODO: Nail down the amount of time.</span>
          with a set of UUIDs that was a superset of the UUIDs for the current scan,
          then the UA MAY return the result of that scan and abort these steps.
        </li>
        <li>Let <var>nearbyDevices</var> be a set of <a>Bluetooth device</a>s, initially empty.</li>
        <li>
          If the UA supports the LE transport, perform the <a>General Discovery Procedure</a>
          and add the discovered <a>Bluetooth device</a>s to <var>nearbyDevices</var>.
          The UA SHOULD enable the <a>Privacy Feature</a>.

          <p class="issue">
            Both <a>passive scanning</a> and
            the <a>Privacy Feature</a> avoid leaking the unique, immutable device ID.
            We ought to require UAs to use either one,
            but none of the OS APIs appear to expose either.
            Bluetooth also makes it hard to use <a>passive scanning</a> since
            it doesn't require <a>Central</a> devices to support the
            <a>Observation Procedure</a>.
          </p>
        </li>
        <li>
          If the UA supports the BR/EDR transport, perform the <a>Device Discovery</a> procedure
          and add the discovered <a>Bluetooth device</a>s to <var>nearbyDevices</var>.

          <p class="issue">
            All forms of BR/EDR inquiry/discovery
            appear to leak the unique, immutable device address.
          </p>
        </li>
        <li>Let <var>result</var> be a set of <a>Bluetooth device</a>s, initially empty.</li>
        <li>
          For each <a>Bluetooth device</a> <var>device</var> in <var>nearbyDevices</var>,
          do the following substeps:
          <ol>
            <li>
              If <var>device</var>'s <a>supported physical transports</a> include LE and
              its <a>Bluetooth Device Name</a> is partial or absent,
              the UA SHOULD perform the <a>Name Discovery Procedure</a>
              to acquire a complete name.
            </li>
            <li>
              If <var>device</var>'s advertised <a title="Service UUID Data Type">Service UUIDs</a>
              have a non-empty intersection with the <var>set of <a>Service</a> UUIDs</var>,
              add <var>device</var> to <var>result</var> and abort these substeps.

              <p class="note">
                For BR/EDR devices, there is no way to distinguish GATT from non-GATT services
                in the <a>Extended Inquiry Response</a>.
                If a site filters to the UUID of a non-GATT service,
                the user may be able to select a device
                for the result of <code>requestDevice</code>
                that this API provides no way to interact with.
              </p>
            </li>
            <li>
              The UA MAY connect to <var>device</var> and <a>populate the Bluetooth cache</a>
              with all Services whose UUIDs are in the <var>set of <a>Service</a> UUIDs</var>.
              If <var>device</var>'s <a>supported physical transports</a> include BR/EDR,
              then in addition to the standard GATT procedures,
              the UA MAY use the Service Discovery Protocol (<a>Searching for Services</a>)
              when populating the cache.

              <div class="note" id="note-extra-discovery">
                <p>
                  Connecting to every nearby device to discover services costs power and
                  can slow down other use of the Bluetooth radio.
                  UAs should only discover extra services on a device if
                  they have some reason to expect that device to be interesting.
                </p>

                <p>
                  UAs should also help developers avoid relying on this extra discovery behavior.
                  For example, say a developer has previously connected to a device,
                  so the UA knows the device's full set of supported services.
                  If this developer then filters using a non-advertised UUID,
                  the dialog they see may include this device,
                  even if the filter would likely exclude the device on users' machines.
                  The UA could provide a developer option to warn when this happens or
                  to include only advertised services in matching filters.
                </p>
              </div>
            </li>
            <li>
              If the <a>Bluetooth cache</a> contains
              known-present Services inside <var>device</var>
              with UUIDs in the <var>set of <a>Service</a> UUIDs</var>,
              the UA MAY add <var>device</var> to <var>result</var>.
            </li>
          </ol>
        </li>
        <li>Return <var>result</var> from the scan.</li>
      </ol>

      <p class="issue">
        We need a way for a site to register to receive an event
        when an interesting device comes within range.
      </p>
    </section>

    <section>
      <h2>Device Representation</h2>

      <p>
        The UA needs to track Bluetooth device properties at several levels:
        globally, per origin, and per <a>script execution environment</a>.
      </p>

      <section>
        <h2>Global Bluetooth device properties</h2>

        <p>
          The physical Bluetooth device may be guaranteed to have
          some properties that the UA may not have received.
          Those properties are described as optional here.
        </p>

        <p>
          A <dfn>Bluetooth device</dfn> has the following properties.
          Optional properties are not present, and sequence and map properties are empty,
          unless/until described otherwise.
          Other properties have a default specified or are specified when a device is introduced.
        </p>

        <ul>
          <li>
            A set of <dfn>supported physical transports</dfn>,
            including one or both of BR/EDR and LE.
            This set will generally be filled based on
            the transports over which the device was discovered
            and the <a>Flags Data Type</a>
            in the <a>Advertising Data</a> or <a>Extended Inquiry Response</a>.
          </li>
          <li>
            One or more of several kinds of 48-bit address:
            a <a>Public Bluetooth Address</a>, a (random) <a>Static Address</a>,
            and a resolvable or non-resolvable <a>Private Address</a>.
          </li>
          <li>An optional 128-bit <a>Identity Resolving Key</a>.</li>

          <li>
            An optional partial or complete <a>Bluetooth Device Name</a>.
            A device has a partial name when the <a>Shortened Local Name</a> AD data was received,
            but the full name hasn't been read yet.
          </li>

          <li>
            An <a>ATT Bearer</a>, over which all GATT communication happens.
            The <a>ATT Bearer</a> is created by procedures described in
            "Connection Establishment" under <a>GAP Interoperability Requirements</a>.
            It is disconnected in ways [[BLUETOOTH42]] isn't entirely clear about.
          </li>

          <li>
            A <dfn>bonded flag</dfn>, indicating whether the Bluetooth device is bonded to the UA.
            Devices bond using the <a>Bonding Procedure</a>.
            <p class="note">
              The Bluetooth standard uses "pairing" to refer to
              creating and exchanging a shared secret,
              and "bonding" to refer to storing that secret for use in subsequent connections.
              Platform APIs don't give independent control of the two processes,
              and they present the combined process to users under the label "pairing",
              so this specification uses "pairing" and "bonding" interchangeably
              to refer to Bluetooth bonding.
            </p>
          </li>

          <li>
            The following optional elements
            from <a>Advertising Data</a> or the <a>Extended Inquiry Response</a>:
            <ul>
              <li>A list of advertised <a title="Service UUID Data Type">Service UUID</a>s.</li>
              <li>
                <a>Manufacturer Specific Data</a>,
                consisting of a map from 16-bit Company Identifier Codes to byte arrays.
                This is treated as an empty map if it's not present.
              </li>
              <li>A <a>TX Power Level</a>, from -127dBm to 127dBm.</li>
              <li>
                <a>Service Data</a>, consisting of a map from UUIDs to byte arrays.
                This is treated as an empty map if it's not present.
              </li>
              <li>
                An <a>Appearance</a>, one of the values defined by
                the <a>org.bluetooth.characteristic.gap.appearance</a> characteristic.
              </li>
              <li>
                A <a>Received Signal Strength Indication</a> (RSSI), from -127dBm to 20dBm.
                This is received from the local Bluetooth adapter
                rather than being sent by the remote device.
              </li>
            </ul>
          </li>

          <li>
            An optional <a>Class of Device</a>,
            one of the values defined in [[!BLUETOOTH-ASSIGNED-BASEBAND]].
            The Class of Device is only used over the BR/EDR physical transport, not LE.
          </li>

          <li>
            A hierarchy of GATT attributes, described in <a href="#information-model"></a>.
          </li>
        </ul>

        <p>
          The UA SHOULD determine that
          two <a>Bluetooth device</a>s are the <dfn>same device</dfn> if and only if
          they have the same <a>Public Bluetooth Address</a>, <a>Static Address</a>,
          <a>Private Address</a>, or <a>Identity Resolving Key</a>,
          or if the <a>Resolvable Private Address Resolution Procedure</a> succeeds using
          one device's IRK and the other's Resolvable <a>Private Address</a>.
          However, because platform APIs don't document how they determine device identity,
          the UA MAY use another procedure.
        </p>
      </section>

      <section>
        <h2>Per-origin Bluetooth device properties</h2>

        <p>
          For each origin, the UA MUST maintain an <dfn>allowed devices map</dfn>,
          whose keys are the <a>Bluetooth device</a>s the origin is allowed to access,
          and whose values are pairs of a <code>DOMString</code> <dfn>device id</dfn> and
          an <dfn>allowed services list</dfn> consisting of UUIDs
          for GATT Primary <a>Service</a>s the origin is allowed to access on the device.
        </p>

        <p>
          The UA MAY remove devices from the <a>allowed devices map</a> at any time
          based on signals from the user.
          <span class="issue">
            This needs a definition involving
            removing <a>BluetoothDevice</a> instances from <a>device instance map</a>s
            and clearing out their [[\representedDevice]] fields.
          </span>
          For example, if the user chooses not to remember access,
          the UA might remove a device when the tab that was granted access to it is closed.
          Or the UA might provide a revocation UI that allows the user
          to explicitly remove a device even while a tab is actively using that device.
          If a device is removed from this list while
          a <a>Promise</a> is pending to do something with the device,
          it MUST be treated the same as if the device moved out of Bluetooth range.
        </p>

        <p>
          To <dfn>add an allowed <a>Bluetooth device</a></dfn> <var>device</var>
          to an origin's <a>allowed devices map</a>
          with an optional <var>allowed services</var> list of <a>UUID</a>s,
          the UA MUST run the following steps.
        </p>
        <ol>
          <li>
            If <var>device</var> is the <a>same device</a> as
            an existing key in the <a>allowed devices map</a>,
            abort these steps.
          </li>
          <li>
            Let <var>id</var> be a new <code>DOMString</code> that
            isn't equal to any of the <a>device id</a>s in the origin's <a>allowed devices map</a>
            and isn't equal to or derived from any of <var>device</var>'s
            <a>Public Bluetooth Address</a>, <a>Static Address</a>,
            or <a>Identity Resolving Key</a>.
            <var>id</var> MUST, with very high probability,
            be unequal to the <a>device id</a>s used for keys
            in any other origin's <a>allowed devices map</a>
            or previously in this origin's <a>allowed devices map</a>
            that are the <a>same device</a> as <var>device</var>.
          </li>
          <li>
            If <var>allowed services</var> wasn't provided, set it to an empty list.
          </li>
          <li>
            Add a mapping from <var>device</var>
            to a pair of <var>id</var> and <var>allowed services</var>
            in the <a>allowed devices map</a>.
          </li>
        </ol>
      </section>

      <section dfn-for="BluetoothDevice">
        <h2><a>BluetoothDevice</a></h2>

        <p>
          A <a>BluetoothDevice</a> instance represents a <a>Bluetooth device</a>
          inside a particular <a>script execution environment</a>.
        </p>

        <pre class="idl">
          // Allocation authorities for Vendor IDs:
          enum VendorIDSource {
            "bluetooth",
            "usb"
          };

          interface BluetoothDevice : ServiceEventHandlers {
            readonly attribute DOMString instanceID;
            readonly attribute DOMString? name;
            readonly attribute BluetoothAdvertisingData adData;
            readonly attribute unsigned long? deviceClass;
            readonly attribute VendorIDSource? vendorIDSource;
            readonly attribute unsigned long? vendorID;
            readonly attribute unsigned long? productID;
            readonly attribute unsigned long? productVersion;
            readonly attribute boolean paired;
            readonly attribute BluetoothGATTRemoteServer? gattServer;
            readonly attribute UUID[] uuids;
            Promise&lt;BluetoothGATTRemoteServer> connectGATT();
          };
        </pre>

        <div class="note" title="BluetoothDevice attributes">
          <p>
            <dfn>instanceID</dfn> uniquely identifies a device to the extent that
            the UA can determine that two Bluetooth connections are to the same device.
            It is computed as the <a>device id</a> in <a>add an allowed Bluetooth device</a>.
            This ID can't be used to match a device across origins
            or after the user revokes and re-grants access to the device.
          </p>

          <p>
            <dfn>name</dfn> is the human-readable name of the device.
          </p>

          <p>
            <dfn>adData</dfn> contains the most recent advertising data received for this device.
            <span class="issue">TODO: Write the algorithm to update this
              when an advertising packet is received.</span>
          </p>

          <p>
            <dfn>deviceClass</dfn> is the class of the device,
            a bit-field defined by [[!BLUETOOTH-ASSIGNED-BASEBAND]].
          </p>

          <p>
            <dfn>vendorIDSource</dfn> is
            the Vendor ID Source field
            in the <a href="https://developer.bluetooth.org/gatt/characteristics/Pages/CharacteristicViewer.aspx?u=org.bluetooth.characteristic.pnp_id.xml">pnp_id</a> characteristic
            in the <a href="https://developer.bluetooth.org/gatt/services/Pages/ServiceViewer.aspx?u=org.bluetooth.service.device_information.xml">device_information</a> service.
          </p>
          <p>
            <dfn>vendorID</dfn> is the 16-bit Vendor ID field
            in the <a href="https://developer.bluetooth.org/gatt/characteristics/Pages/CharacteristicViewer.aspx?u=org.bluetooth.characteristic.pnp_id.xml">pnp_id</a> characteristic
            in the <a href="https://developer.bluetooth.org/gatt/services/Pages/ServiceViewer.aspx?u=org.bluetooth.service.device_information.xml">device_information</a> service.
          </p>
          <p>
            <dfn>productID</dfn> is the 16-bit Product ID field
            in the <a href="https://developer.bluetooth.org/gatt/characteristics/Pages/CharacteristicViewer.aspx?u=org.bluetooth.characteristic.pnp_id.xml">pnp_id</a> characteristic
            in the <a href="https://developer.bluetooth.org/gatt/services/Pages/ServiceViewer.aspx?u=org.bluetooth.service.device_information.xml">device_information</a> service.
          </p>
          <p>
            <dfn>productVersion</dfn> is the 16-bit Product Version field in the
            <a href="https://developer.bluetooth.org/gatt/characteristics/Pages/CharacteristicViewer.aspx?u=org.bluetooth.characteristic.pnp_id.xml">pnp_id</a>
            characteristic in the
            <a href="https://developer.bluetooth.org/gatt/services/Pages/ServiceViewer.aspx?u=org.bluetooth.service.device_information.xml">device_information</a>
            service.
          </p>

          <p>
            <dfn>paired</dfn> indicates whether or not the device is paired with the system.
          </p>

          <p>
            If the UA is currently connected to this device's GATT server,
            <dfn>gattServer</dfn> provides a way to interact with it.
            While this device is disconnected,
            <a for="BluetoothDevice">gattServer</a> is <code>null</code>.
          </p>

          <p>
            <dfn>uuids</dfn> lists
            the UUIDs of GATT services known to be on the device,
            that the current origin is allowed to access.
          </p>
        </div>

        <p>
          For each <a>script execution environment</a>,
          the UA must maintain a <dfn>device instance map</dfn>
          mapping <a>Bluetooth device</a>s
          to <code>Promise&lt;<a>BluetoothDevice</a>></code> instances.
          To <dfn>get the <code>BluetoothDevice</code> representing</dfn>
          a <a>Bluetooth device</a> <var>device</var>,
          the UA MUST run the following steps:
        </p>
        <ol>
          <li>
            If there is a key in
            the current <a>script execution environment</a>'s <a>device instance map</a>
            that is the <a>same device</a> as <var>device</var>,
            return its value and abort these steps.
          </li>
          <li>Let <var>promise</var> be <a>a new promise</a>.</li>
          <li>
            Add a mapping from <var>device</var> to <var>promise</var>
            in the current <a>script execution environment</a>'s <a>device instance map</a>.
          </li>
          <li>Return <var>promise</var>, and run the following steps <a>in parallel</a>.
            <ol>
              <li>Let <var>result</var> be a new instance of <a>BluetoothDevice</a>.</li>
              <li>Initialize all of <var>result</var>'s optional fields to <code>null</code>.</li>
              <li>
                Initialize an internal
                <code><var>result</var>@[[\representedDevice]]</code> field
                to <var>device</var>.
              </li>
              <li>
                Find the key in this origin's <a>allowed devices map</a>
                that is the <a>same device</a> as <var>device</var>.
                If there is no such key,
                <a>resolve</a> <var>promise</var> with a <a>SecurityError</a> and abort these steps.
                Otherwise, initialize <code><var>result</var>.instanceID</code>
                to the <a>device id</a> this key maps to,
                and initialize an internal
                <code><var>result</var>@[[\allowedServices]]</code> field
                to the <a>allowed services list</a> this key maps to.
              </li>
              <li>
                If <var>device</var> has a partial or complete <a>Bluetooth Device Name</a>,
                set <code><var>result</var>.name</code> to that string.
              </li>
              <li>
                <a>Create a <code>BluetoothAdvertisingData</code></a> from <var>device</var>
                and <code><var>result</var>@[[\allowedServices]]</code>,
                and set <code><var>result</var>.adData</code> to the result.
              </li>
              <li>
                If <var>device</var> has a <a>Class of Device</a>,
                set <code><var>result</var>.deviceClass</code> to that value.
              </li>
              <li>
                <a>Populate the Bluetooth cache</a> with
                the <a>org.bluetooth.characteristic.pnp_id</a> characteristic inside
                the <a>org.bluetooth.service.device_information</a> service.
                Ignore any errors from this step.
              </li>
              <li>
                If the <a>Bluetooth cache</a> now has a known-present entry for this characteristic,
                run the following substeps.
                <ol>
                  <li>
                    Use any combination of the sub-procedures in
                    the <a>Characteristic Value Read</a> procedure to retrieve the value
                    of the <a>org.bluetooth.characteristic.pnp_id</a> characteristic
                    into <var>pnp</var>.
                    Handle errors as described in <a href="#error-handling"></a>.
                  </li>
                  <li>If the previous step returned an error, abort these substeps.</li>
                  <li>
                    Parse <var>pnp</var> as specified by
                    the <a>org.bluetooth.characteristic.pnp_id</a> characteristic definition.
                    If it's not 7 bytes long or
                    if the Vendor ID Source is not <code>1</code> or <code>2</code>,
                    abort these substeps.
                  </li>
                  <li>
                    Set <code><var>result</var>.vendorIDSource</code> according to the following table:
                    <table>
                      <tr><th>Parsed Vendor Id Source</th><th><code>vendorIDSource</code></th></tr>
                      <tr><td>1</td><td><code>"bluetooth"</code></td></tr>
                      <tr><td>2</td><td><code>"usb"</code></td></tr>
                    </table>
                  </li>
                  <li>
                    Set <code><var>result</var>.vendorID</code> to the value parsed for Vendor ID.
                  </li>
                  <li>
                    Set <code><var>result</var>.productID</code> to the value parsed for Product ID.
                  </li>
                  <li>
                    Set <code><var>result</var>.productVersion</code> to
                    the value parsed for Product Version.
                  </li>
                </ol>
              </li>
              <li>
                Initialize <code><var>result</var>.paired</code> to
                the value of <var>device</var>'s <a>bonded flag</a>.
              </li>
              <li>
                Let <var>uuids</var> be an empty set of UUIDs.
              </li>
              <li>
                Add <var>device</var>'s
                advertised <a title="Service UUID Data Type">Service UUID</a>s
                to <var>uuids</var>.
              </li>
              <li>
                The UA MAY <a>populate the Bluetooth cache</a> with
                all Services inside <var>device</var>.
                Ignore any errors from this step.
              </li>
              <li>
                If the <a>Bluetooth cache</a> contains
                known-present Services inside <var>device</var>,
                add the UUIDs of those Services to <var>uuids</var>.
              </li>
              <li>
                Initialize <code><var>result</var>.uuids</code> to
                a <a>read only Array</a> holding the elements of <var>uuids</var>
                that are also in <code><var>result</var>@[[\allowedServices]]</code>.
              </li>
              <li>Resolve <var>promise</var> with <var>result</var>.</li>
            </ol>
          </li>
        </ol>

        <p>
          The <code><dfn>connectGATT</dfn>()</code> method, when invoked,
          MUST return <a>a new promise</a> <var>promise</var> and
          run the following steps <a>in parallel</a>:
        </p>
        <ol>
          <li>
            If <code>this@[[\representedDevice]]</code> has no <a>ATT Bearer</a>,
            attempt to create one using the procedures described
            in "Connection Establishment" under <a>GAP Interoperability Requirements</a>.
          </li>
          <li>
            If this attempt fails,
            reject <var>promise</var> with a <a>NetworkError</a> and abort these steps.
          </li>
          <li>
            <a>Queue a task</a> to do the following steps:
            <ol>
              <li>
                If <code>this.gattServer</code> is <code>null</code>,
                set it to a new <a>BluetoothGATTRemoteServer</a> instance
                with its <code>device</code> attribute initialized to <code>this</code>
                and its <code>connected</code> attribute initialized to <code>true</code>.
              </li>
              <li>
                Resolve <var>promise</var> with <code>this.gattServer</code>.
              </li>
            </ol>
          </li>
        </ol>

        <section dfn-for="BluetoothAdvertisingData">
          <h2><a>BluetoothAdvertisingData</a></h2>

          <pre class="idl">
            [NoInterfaceObject]
            interface BluetoothAdvertisingData {
              readonly attribute unsigned short? appearance;
              readonly attribute byte? txPower;
              readonly attribute byte? rssi;
              readonly attribute Map manufacturerData;
              readonly attribute Map serviceData;
            };
          </pre>

          <div class="note" title="BluetoothAdvertisingData attributes">
            <p>
              <dfn>appearance</dfn> is an <a>Appearance</a>, one of the values defined by
              the <a>org.bluetooth.characteristic.gap.appearance</a> characteristic.
            </p>
            <p>
              <dfn>txPower</dfn> is
              the transmission power at which the device is broadcasting, measured in dBm.
              This is used to compute the path loss as <code>this.txPower - this.rssi</code>.
            </p>
            <p>
              <dfn>rssi</dfn> is
              the power at which the device's packets are being received, measured in dBm.
              This is used to compute the path loss as <code>this.txPower - this.rssi</code>.
            </p>
            <p>
              <dfn>manufacturerData</dfn> maps <code>unsigned short</code> Company Identifier Codes
              to <a>ArrayBuffer</a>s.
            </p>
            <p>
              <dfn>serviceData</dfn> maps <a>UUID</a>s to <a>ArrayBuffer</a>s.
            </p>
          </div>

          <aside class="example">
            <p>
              To retrieve a device and read the iBeacon data out of it,
              a developer could use the following code.
              Note that this API currently doesn't provide a way
              to request devices with certain manufacturer data,
              so the iBeacon will need to rotate its advertisements to include a known service
              in order for users to select this device in the <code>requestDevice</code> dialog.
            </p>

            <pre class="highlight">var known_service = "A service in the iBeacon's GATT server";
return navigator.bluetooth.requestDevice([{services: [known_service]}])
.then(device => {
  var rssi = device.adData.rssi;
  var appleData = new DataView(device.adData.manufacturerData.get(<a
               href="https://www.bluetooth.org/en-us/specification/assigned-numbers/company-identifiers"
               title="Apple, Inc.'s Company Identifier">0x004C</a>));
  if (appleData.byteLength != 23 ||
      appleData.getUint16(0, false) !== 0x0215) {
    return {isBeacon: false};
  }
  var uuidArray = new Uint8Array(appleData.buffer, 2, 16);
  var major = appleData.getUint16(18, false);
  var minor = appleData.getUint16(20, false);
  var txPowerAt1m = -appleData.getInt8(22);
  return {isBeacon: true,
          uuidArray,
          major,
          minor,
          pathLossVs1m: txPowerAt1m - rssi};
});</pre>

            <p>
              The format of iBeacon advertisements was derived from
              <a href="http://www.warski.org/blog/2014/01/how-ibeacons-work/">How do iBeacons work?</a>
              by Adam Warski.
            </p>
          </aside>

          <p>
            All fields in <a>BluetoothAdvertisingData</a> return
            the last value they were initialized or set to.
          </p>

          <p>
            To <dfn>create a <a>BluetoothAdvertisingData</a></dfn>
            from a <a>Bluetooth device</a> <var>device</var>
            and an <var>allowed services list</var>,
            the UA must perform the following steps:
          </p>
          <ol>
            <li>Let <var>adData</var> be a new instance of <a>BluetoothAdvertisingData</a>.</li>
            <li>
              If <var>device</var> has an <a>Appearance</a>,
              initialize <code><var>adData</var>.appearance</code> to its value.
              Otherwise, initialize it to <code>null</code>.
            </li>
            <li>
              If <var>device</var> has a <a>TX Power Level</a>,
              initialize <code><var>adData</var>.txPower</code> to its value.
              Otherwise initialize it to <code>null</code>.
            </li>
            <li>
              If <var>device</var> has an <a>RSSI</a>,
              initialize <code><var>adData</var>.rssi</code> to its value.
              Otherwise initialize it to <code>null</code>.
            </li>
            <li>
              Initialize <code><var>adData</var>.manufacturerData</code> with
              the return value of these substeps:
              <ol>
                <li>Let <var>mdata</var> be a new <a>Map</a> instance.</li>
                <li>
                  For each mapping in <var>device</var>'s <a>Manufacturer Specific Data</a>,
                  make a new <a>read only ArrayBuffer</a> <var>bytes</var>
                  containing the contents of its byte array,
                  and add a mapping from the 16-bit code to <var>bytes</var> in <var>mdata</var>.
                </li>
                <li>
                  Return a <a>read only Map</a> whose value is <var>mdata</var>.
                </li>
              </ol>
            </li>
            <li>
              Initialize <code><var>adData</var>.serviceData</code> with
              the return value of these substeps:
              <ol>
                <li>Let <var>sdata</var> be a new <a>Map</a> instance.</li>
                <li>
                  For each mapping in <var>device</var>'s <a>Service Data</a>,
                  if the UUID is in <var>allowed services list</var>,
                  make a new <a>read only ArrayBuffer</a> <var>bytes</var>
                  containing the contents of its byte array,
                  and add a mapping from the <a>UUID</a> to <var>bytes</var> in <var>sdata</var>.
                </li>
                <li>
                  Return a <a>read only Map</a> whose value is <var>sdata</var>.
                </li>
              </ol>
            </li>
            <li>Return <var>adData</var>.</li>
          </ol>
        </section>
      </section>
    </section>

    <section>
      <h2>GATT Interaction</h2>

      <section id="information-model">
        <h2>GATT Information Model</h2>

        <p class="note">
          The <a>GATT Profile Hierarchy</a> describes how any device that supports <a>GATT</a>
          can contain a hierarchy of Profiles, Primary Services, Included Services,
          Characteristics, and Descriptors.
          Profiles are purely logical:
          the specification of a Profile describes the expected interactions between
          the other GATT entities the Profile contains,
          but it's impossible to query which Profiles a device supports.
          On the other hand,
          GATT defines a set of <a title="GATT procedures">procedures</a> to
          discover and interact with the Services, Characteristics, and Descriptors on a device.
          GATT also defines the <a>Service Changed</a> characteristic to allow clients
          to cache the Services, Characteristics, and Descriptors they have discovered on a device.
          Services, Characteristics, and Descriptors
          can be ordered by their <a>Attribute Handle</a>,
          but while platform interfaces provide these entities in an order,
          they do not guarantee that it's consistent with the <a>Attribute Handle</a> order.
        </p>

        <p>
          The UA MUST maintain a <dfn>Bluetooth cache</dfn>
          of the hierarchy of Services, Characteristics, and Descriptors
          it has discovered on a device.
          The UA MAY share this cache between multiple origins accessing the same device.
          Each potential entity in the cache is either known-present, known-absent, or unknown.
          Each known-present entity in the cache is associated with an optional
          <code>Promise&lt;<a>BluetoothGATTService</a>></code>,
          <code>Promise&lt;<a>BluetoothGATTCharacteristic</a>></code>,
          or <code>Promise&lt;<a>BluetoothGATTDescriptor</a>></code> instance
          for each <a>script execution environment</a>.
        </p>

        <p class="note">
          For example, if a user calls the <code>serviceA.getCharacteristic(uuid1)</code> function
          with an initially empty <a>Bluetooth cache</a>,
          the UA uses the <a>Discover Characteristics by UUID</a> procedure
          to fill the needed cache entries,
          and the UA ends the procedure early because
          it only needs one Characteristic to fulfil the returned <a>Promise</a>,
          then the first Characteristic with UUID <code>uuid1</code> inside <code>serviceA</code>
          is known-present,
          and any subsequent Characteristics with that UUID remain unknown.
          If the user later calls <code>serviceA.getCharacteristics(uuid1)</code>,
          the UA needs to resume or restart the <a>Discover Characteristics by UUID</a> procedure.
          If it turns out that
          <code>serviceA</code> only has one Characteristic with UUID <code>uuid1</code>,
          then the subsequent Characteristics become known-absent.
        </p>

        <p>
          The known-present entries in the <a>Bluetooth cache</a> are ordered:
          Primary Services appear in a particular order within a device,
          Included Services and Characteristics appear in a particular order within Services,
          and Descriptors appear in a particular order within Characteristics.
          The order SHOULD match the order of <a>Attribute Handle</a>s on the device,
          but UAs MAY use another order if the device's order isn't available.
        </p>

        <p>
          To <dfn>populate the Bluetooth cache</dfn> with entries matching some description,
          the UA MUST run the following steps.
          <span class="note">Note that these steps can block,
            so uses of this algorithm must be <a>in parallel</a>.</span>
        </p>
        <ol>
          <li>
            Attempt to make all matching entries in the cache either known-present or known-absent,
            using any sequence of <a>GATT procedures</a> that [[BLUETOOTH42]] specifies
            will return enough information.
            Handle errors as described in <a href="#error-handling"></a>.
          </li>
          <li>
            If the previous step returns an error, return that error from this algorithm.
          </li>
        </ol>

        <p>
          To <dfn>query the Bluetooth cache</dfn> for entries matching some description,
          the UA MUST return <a>a new promise</a> <var>promise</var>
          and run the following steps <a>in parallel</a>:
        </p>
        <ol>
          <li>
            <a>Populate the Bluetooth cache</a> with entries matching the description.
          </li>
          <li>
            If the previous step returns an error,
            <a>reject</a> <var>promise</var> with that error and abort these steps.
          </li>
          <li>
            Let <var>entries</var> be the sequence
            of known-present cache entries matching the description.
          </li>
          <li>
            Let <var>result</var> be a new sequence.
          </li>
          <li>
            For each <var>entry</var> in <var>entries</var>:
            <ol>
              <li>
                If <var>entry</var> has no associated <code>BluetoothGATT*</code> instance
                for the current <a>script execution environment</a>,
                <a>create a <code>BluetoothGATTService</code>
                representing</a> <var>entry</var>,
                <a>create a <code>BluetoothGATTCharacteristic</code>
                representing</a> <var>entry</var>,
                or <a>create a <code>BluetoothGATTDescriptor</code>
                representing</a> <var>entry</var>,
                depending on whether <var>entry</var> is a Service, Characteristic, or Descriptor,
                and associate the resulting <code>Promise</code> with <var>entry</var>.
              </li>
              <li>
                Append to <var>result</var>
                the <code>Promise&lt;BluetoothGATT*></code> instance
                associated with <var>entry</var>
                for the current <a>script execution environment</a>.
              </li>
            </ol>
          </li>
          <li>
            <a>Resolve</a> <var>promise</var> with the result of
            <a>waiting for all</a> elements of <var>result</var>.
          </li>
        </ol>

        <section>
          <h2>Identifying Services, Characteristics, and Descriptors</h2>

          <p>
            When checking whether two Services, Characteristics, or Descriptors
            <var>a</var> and <var>b</var> are the <dfn>same attribute</dfn>,
            the UA SHOULD determine that they are the same if <var>a</var> and <var>b</var>
            are inside the <a>same device</a> and have the same <a>Attribute Handle</a>,
            but MAY use any algorithm it wants with the constraint that
            <var>a</var> and <var>b</var> MUST NOT be considered the <a>same attribute</a> if
            they fit any of the following conditions:
          </p>
          <ul>
            <li>They are not both Services, both Characteristics, or both Descriptors.</li>
            <li>They are both Services, but are not both primary or both secondary services.</li>
            <li>They have different UUIDs.</li>
            <li>
              Their parent Devices aren't the <a>same device</a> or
              their parent Services or Characteristics aren't the <a>same attribute</a>.
            </li>
          </ul>

          <p class="note">
            This definition is loose because platform APIs expose their own notion of identity
            without documenting whether it's based on <a>Attribute Handle</a> equality.
          </p>

          <p>
            For each origin, the UA must maintain an <dfn>attribute instance id map</dfn>
            mapping Services, Characteristics, and Descriptors to <code>DOMString</code>s.
          </p>

          <p>
            To <dfn>get an attribute id</dfn> for
            a Service, Characteristic, or Descriptor <var>attribute</var>,
            the UA MUST run the following steps.
          </p>
          <ol>
            <li>
              If <var>attribute</var> is the <a>same attribute</a> as
              a key in this origin's <a>attribute instance id map</a>,
              return the <code>DOMString</code> for that key and abort these steps.
            </li>
            <li>
              Let <var>id</var> be a new <code>DOMString</code> that
              isn't equal to any value in this origin's <a>attribute instance id map</a>.
            </li>
            <li>
              Add a mapping from <var>attribute</var> to <var>id</var> in
              this origin's <a>attribute instance id map</a>.
            </li>
            <li>
              Return <var>id</var>.
            </li>
          </ol>
        </section>
      </section>

      <section dfn-for="BluetoothGATTRemoteServer">
        <h2><a>BluetoothGATTRemoteServer</a></h2>

        <pre class="idl">
          interface BluetoothGATTRemoteServer : ServiceEventHandlers {
            readonly attribute BluetoothDevice device;
            readonly attribute boolean connected;
            void disconnect();
            Promise&lt;BluetoothGATTService> getPrimaryService(BluetoothServiceUUID service);
            Promise&lt;sequence&lt;BluetoothGATTService>>
              getPrimaryServices(optional BluetoothServiceUUID service);
          };
        </pre>

        <div class="note" title="BluetoothGATTRemoteServer attributes">
          <p>
            <dfn>device</dfn> is the device running this server.
          </p>

          <p>
            <dfn>connected</dfn> is true while this <a>script execution environment</a>
            is connected to <code>this.device</code>.
            It can be false while the UA is physically connected.
          </p>
        </div>

        <p>
          The <code><dfn>disconnect</dfn>()</code> method, when invoked,
          MUST perform the following steps:
        </p>
        <ol>
          <li>
            Set <code>this.connected</code> to <code>false</code>.
          </li>
          <li>
            <a>In parallel</a>:
            if, for all <a>script execution environment</a>s,
            all <a>BluetoothDevice</a>s <code><var>device</var></code>
            with <code><var>device</var>@[[\representedDevice]]</code>
            the <a>same device</a> as <code>this.device@[[\representedDevice]]</code>,
            <code><var>device</var>.gattServer === null</code>
            or <code>!<var>device</var>.gattServer.connected</code>,
            the UA MAY destroy
            <code><var>device</var>@[[\representedDevice]]</code>'s <a>ATT Bearer</a>.
          </li>
        </ol>

        <p>
          The <code><dfn>getPrimaryService</dfn>(<var>service</var>)</code> method, when invoked,
          MUST perform the following steps:
        </p>
        <ol>
          <li>
            <a>Query the Bluetooth cache</a> for
            the first primary GATT service
            on <code>this@[[\representedDevice]]</code>
            whose UUID is <var>service</var>
            and whose UUID is in <code>this@[[\allowedServices]]</code>,
            and let <var>promise</var> be the result.
          </li>
          <li>
            Return the result of
            <a>transforming</a> <var>promise</var> with a fulfilment handler that
            returns <code>null</code> if its argument is empty
            or returns the first (only) element of its argument.
          </li>
        </ol>

        <p>
          The <code><dfn>getPrimaryServices</dfn>(<var>service</var>)</code> method, when invoked,
          MUST <a>query the Bluetooth cache</a> for the primary GATT services
          on <code>this@[[\representedDevice]]</code>
          whose UUIDs are in <code>this@[[\allowedServices]]</code>
          and, if <var>service</var> is present, whose UUIDs are equal to <var>service</var>,
          and return the result.
        </p>
      </section>

      <section dfn-for="BluetoothGATTService">
        <h2><a>BluetoothGATTService</a></h2>

        <p><a>BluetoothGATTService</a> represents a GATT <a>Service</a> within a Bluetooth <a>Peripheral</a>, a collection of characteristics and relationships to other services that encapsulate the behavior of part of a device.</p>

        <pre class="idl">
          interface BluetoothGATTService : ServiceEventHandlers {
            readonly attribute UUID uuid;
            readonly attribute boolean isPrimary;
            readonly attribute DOMString instanceID;
            readonly attribute BluetoothDevice device;
            Promise&lt;BluetoothGATTCharacteristic>
              getCharacteristic(BluetoothCharacteristicUUID characteristic);
            Promise&lt;sequence&lt;BluetoothGATTCharacteristic>>
              getCharacteristics(optional BluetoothCharacteristicUUID characteristic);
            Promise&lt;BluetoothGATTService>
              getIncludedService(BluetoothServiceUUID service);
            Promise&lt;sequence&lt;BluetoothGATTService>>
              getIncludedServices(optional BluetoothServiceUUID service);
          };
        </pre>

        <div class="note" title="BluetoothGATTService attributes">
          <p>
            <dfn>uuid</dfn> is the UUID of the service,
            e.g. <code>'0000180d-0000-1000-8000-00805f9b34fb'</code> for the
            <a href="https://developer.bluetooth.org/gatt/services/Pages/ServiceViewer.aspx?u=org.bluetooth.service.heart_rate.xml"
               >Heart Rate</a> service.
          </p>
          <p>
            <dfn>isPrimary</dfn> indicates whether the type of this service is primary or secondary.
          </p>

          <p>
            <dfn>instanceID</dfn> is the opaque identifier assigned to this service,
            which can be used distinguish between
            multiple primary services with the same UUID in a single device or
            multiple included services with the same UUID in a single primary service.
            It is computed by the <a>get an attribute id</a> algorithm.
          </p>

          <p>
            <dfn>device</dfn> is the <a>BluetoothDevice</a> representing
            the remote peripheral that the GATT service belongs to.
          </p>
        </div>

        <p>
          To <dfn>create a <code>BluetoothGATTService</code> representing</dfn>
          a Service <var>service</var>,
          the UA must return <a>a new promise</a> <var>promise</var>
          and run the following steps <a>in parallel</a>.
        </p>
        <ol>
          <li>Let <var>result</var> be a new instance of <a>BluetoothGATTService</a>.</li>
          <li>
            Initialize <code><var>result</var>.uuid</code> from the UUID of <var>service</var>.
          </li>
          <li>
            If <var>service</var> is a Primary Service,
            initialize <code><var>result</var>.isPrimary</code> to true.
            Otherwise initialize <code><var>result</var>.isPrimary</code> to false.
          </li>
          <li>
            <a>Get the <code>BluetoothDevice</code> representing</a>
            the device in which <var>service</var> appears,
            and let <var>devicePromise</var> be the result.
          </li>
          <li>Wait for <var>devicePromise</var> to settle.</li>
          <li>
            If <var>devicePromise</var> rejected,
            <a>resolve</a> <var>promise</var> with <var>devicePromise</var> and abort these steps.
          </li>
          <li>
            Initialize <code><var>result</var>.device</code> from
            the value of <var>devicePromise</var>.
          </li>
          <li>
            <a>Get an attribute id</a> for <var>service</var>,
            and initialize <code><var>result</var>.instanceID</code> to the result.
          </li>
          <li><a>Resolve</a> <var>promise</var> with <var>result</var>.</li>
        </ol>

        <p>
          The <code><dfn>getCharacteristic</dfn>(<var>characteristic</var>)</code> method, when invoked,
          MUST perform the following steps:
        </p>
        <ol>
          <li>
            <a>Query the Bluetooth cache</a> for
            the first GATT characteristic within this Service
            whose UUID is <var>characteristic</var>,
            and let <var>promise</var> be the result.
          </li>
          <li>
            Return the result of
            <a>transforming</a> <var>promise</var> with a fulfilment handler that
            returns <code>null</code> if its argument is empty
            or returns the first (only) element of its argument.
          </li>
        </ol>

        <p>
          The <code><dfn>getCharacteristics</dfn>(<var>characteristic</var>)</code> method, when invoked,
          MUST <a>query the Bluetooth cache</a> for
          the GATT characteristics that are within this Service and,
          if <var>characteristic</var> is present,
          that have UUIDs equal to <var>characteristic</var>,
          and return the result.
        </p>

        <p>
          The <code><dfn>getIncludedService</dfn>(<var>service</var>)</code> method, when invoked,
          MUST perform the following steps:
        </p>
        <ol>
          <li>
            <a>Query the Bluetooth cache</a> for the first GATT included service
            within this Service whose UUID is <var>service</var>,
            and let <var>promise</var> be the result.
          </li>
          <li>
            Return the result of
            <a>transforming</a> <var>promise</var> with a fulfilment handler that
            returns <code>null</code> if its argument is empty
            or returns the first (only) element of its argument.
          </li>
        </ol>

        <p>
          The <code><dfn>getIncludedServices</dfn>(<var>service</var>)</code> method, when invoked,
          MUST <a>query the Bluetooth cache</a> for
          the GATT Included Services that are within this Service and,
          if <var>service</var> is present,
          that have UUIDs equal to <var>service</var>,
          and return the result.
        </p>
      </section>

      <section dfn-for="BluetoothGATTCharacteristic">
        <h2><a>BluetoothGATTCharacteristic</a></h2>

        <p><a>BluetoothGATTCharacteristic</a> represents a GATT <a>Characteristic</a>, which is a basic data element that provides further information about a peripheral's service.</p>

        <pre class="idl">
          interface BluetoothGATTCharacteristic : CharacteristicEventHandlers {
            readonly attribute UUID uuid;
            readonly attribute BluetoothGATTService service;
            readonly attribute CharacteristicProperties properties;
            readonly attribute DOMString instanceID;
            readonly attribute ArrayBuffer? value;
            Promise&lt;BluetoothGATTDescriptor> getDescriptor(BluetoothDescriptorUUID descriptor);
            Promise&lt;sequence&lt;BluetoothGATTDescriptor>>
              getDescriptors(optional BluetoothDescriptorUUID descriptor);
            Promise&lt;ArrayBuffer> readValue();
            Promise&lt;void> writeValue(ArrayBuffer value);
            Promise&lt;void> startNotifications();
            Promise&lt;void> stopNotifications();
          };
        </pre>

        <div class="note" title="BluetoothGATTCharacteristic attributes">
          <p>
            <dfn>uuid</dfn> is the UUID of the characteristic,
            e.g. <code>'00002a37-0000-1000-8000-00805f9b34fb'</code> for the
            <a href="https://developer.bluetooth.org/gatt/characteristics/Pages/CharacteristicViewer.aspx?u=org.bluetooth.characteristic.heart_rate_measurement.xml"
               >Heart Rate Measurement</a> characteristic.
          </p>
          <p>
            <dfn>service</dfn> is the GATT service this characteristic belongs to.
          </p>
          <p>
            <dfn>properties</dfn> holds the properties of this characteristic.
          </p>
          <p>
            <dfn>instanceID</dfn> is the opaque identifier assigned to this characteristic,
            which can be used distinguish between
            multiple characteristics with the same UUID in a single service.
            It is computed by the <a>get an attribute id</a> algorithm.
          </p>
          <p>
            <dfn>value</dfn> is the currently cached characteristic value.
            This value gets updated when the value of the characteristic is read or updated via a notification or indication.
          </p>
        </div>

        <p>
          To <dfn>create a <code>BluetoothGATTCharacteristic</code> representing</dfn>
          a Characteristic <var>characteristic</var>,
          the UA must return <a>a new promise</a> <var>promise</var>
          and run the following steps <a>in parallel</a>.
        </p>
        <ol>
          <li>Let <var>result</var> be a new instance of <a>BluetoothGATTCharacteristic</a>.</li>
          <li>
            Initialize <code><var>result</var>.uuid</code> from
            the UUID of <var>characteristic</var>.
          </li>
          <li>
            Initialize <code><var>result</var>.service</code> from
            the <a>BluetoothGATTService</a> instance representing
            the Service in which <var>characteristic</var> appears.
          </li>
          <li>
            <a>Get an attribute id</a> for <var>characteristic</var>,
            and initialize <code><var>result</var>.instanceID</code> to the result.
          </li>
          <li>
            <a>Create a <code>CharacteristicProperties</code> instance
            from the Characteristic</a> <var>characteristic</var>,
            and let <var>propertiesPromise</var> be the result.
          </li>
          <li>Wait for <var>propertiesPromise</var> to settle.</li>
          <li>
            If <var>propertiesPromise</var> was rejected,
            <a>resolve</a> <var>promise</var> with <var>propertiesPromise</var> and
            abort these steps.
          </li>
          <li>
            Initialize <code><var>result</var>.properties</code> from
            the value <var>propertiesPromise</var> was fulfilled with.
          </li>
          <li>
            Initialize <code><var>result</var>.value</code> to <code>null</code>.
            The UA MAY initialize <code><var>result</var>.value</code> to
            a new <code>ArrayBuffer</code> containing
            the most recently read value from <var>characteristic</var>
            if this value is available.
          </li>
          <li><a>Resolve</a> <var>promise</var> with <var>result</var>.</li>
        </ol>

        <p>
          The <code><dfn>getDescriptor</dfn>(<var>descriptor</var>)</code> method, when invoked,
          MUST perform the following steps:
        </p>
        <ol>
          <li>
            <a>Query the Bluetooth cache</a> for
            the first GATT descriptor within this Characteristic
            whose UUID is <var>descriptor</var>,
            and let <var>promise</var> be the result.
          </li>
          <li>
            Return the result of
            <a>transforming</a> <var>promise</var> with a fulfilment handler that
            returns <code>null</code> if its argument is empty
            or returns the first (only) element of its argument.
          </li>
        </ol>

        <p>
          The <code><dfn>getDescriptors</dfn>(<var>descriptor</var>)</code> method, when invoked,
          MUST <a>query the Bluetooth cache</a> for
          the GATT descriptors that are within this Characteristic and,
          if <var>descriptor</var> is present,
          that have UUIDs equal to <var>descriptor</var>,
          and return the result.
        </p>

        <p>
          The <code><dfn>readValue</dfn>()</code> method, when invoked,
          MUST return <a>a new promise</a> <var>promise</var>
          and run the following steps <a>in parallel</a>:
        </p>
        <ol>
          <li>
            Let <var>characteristic</var> be the <a>Characteristic</a>
            that <code>this</code> represents.
          </li>
          <li>
            If the <code>Read</code> bit is not set
            in <var>characteristic</var>'s <a title="Characteristic Properties">properties</a>,
            <a>reject</a> <var>promise</var> with a <a>NotSupportedError</a> and abort these steps.
          </li>
          <li>
            Use any combination of the sub-procedures in
            the <a>Characteristic Value Read</a> procedure
            to retrieve the value of <var>characteristic</var>.
            Handle errors as described in <a href="#error-handling"></a>.
          </li>
          <li>
            If the previous step returned an error,
            <a>reject</a> <var>promise</var> with that error and abort these steps.
          </li>
          <li>
            <a>Queue a task</a> to perform the following steps:
            <ol>
              <li>
                Create an <code>ArrayBuffer</code> holding the retrieved value,
                and assign it to <code>this.value</code>.
              </li>
              <li>
                <a>Resolve</a> <var>promise</var> with <code>this.value</code>.
              </li>
              <li>
                <a>Fire an event</a> named <a><code>characteristicvaluechanged</code></a>
                with its <code>bubbles</code> attribute initialized to <code>true</code>
                at <code>this</code>.
              </li>
            </ol>
          </li>
        </ol>

        <p>
          The <code><dfn>writeValue</dfn>(<var>value</var>)</code> method, when invoked,
          MUST write <code><var>value</var></code> to this characteristic on the remote peripheral.
        </p>

        <p>
          For each known GATT <a>Characteristic</a>, the UA MUST maintain
          an <dfn>active notification context set</dfn> of <a>Bluetooth</a> objects.
          This is a single set for the whole UA,
          pointing to the <a href="#idl-def-navigator-bluetooth"><code>navigator.bluetooth</code></a> object
          for each separate <a>script execution environment</a> that has registered for notifications.
        </p>

        <p>
          The <code><dfn>startNotifications</dfn>()</code> method, when invoked,
          MUST return <a>a new promise</a> <var>promise</var>
          and run the following steps <a>in parallel</a>.
          See <a href="#notification-events"></a> for details of receiving notifications.
        </p>
        <ol>
          <li>
            Let <var>characteristic</var> be
            the GATT <a>Characteristic</a> that <code>this</code> represents.
          </li>
          <li>
            If neither of the <code>Notify</code> or <code>Indicate</code> bits are set
            in <var>characteristic</var>'s <a title="Characteristic Properties">properties</a>,
            <a>reject</a> <var>promise</var> with a <a>NotSupportedError</a> and abort these steps.
          </li>
          <li>
            If the <a>active notification context set</a> contains
            <a href="#idl-def-navigator-bluetooth"><code>navigator.bluetooth</code></a>,
            <a>resolve</a> <var>promise</var> with <code>undefined</code> and abort these steps.
          </li>
          <li>
            Use any of the <a>Characteristic Descriptors</a> procedures
            to ensure that one of the <code>Notification</code> or <code>Indication</code> bits in
            <var>characteristic</var>'s <a>Client Characteristic Configuration</a> descriptor
            is set, matching the constraints
            in <var>characteristic</var>'s <a title="Characteristic Properties">properties</a>.
            The UA SHOULD avoid setting both bits,
            and MUST deduplicate <a href="#notification-events">value-change events</a>
            if both bits are set.
            Handle errors as described in <a href="#error-handling"></a>.
          </li>
          <li>
            If the previous step returned an error,
            <a>reject</a> <var>promise</var> with that error and abort these steps.
          </li>
          <li>
            Add <a href="#idl-def-navigator-bluetooth"><code>navigator.bluetooth</code></a>
            to the <a>active notification context set</a>.
          </li>
          <li>
            <a>Resolve</a> <var>promise</var> with <code>undefined</code>.
          </li>
        </ol>

        <p class="note">
          After notifications are enabled,
          the resulting <a href="#notification-events">value-change events</a> won't be delivered
          until after the current
          <a title="perform a microtask checkpoint">microtask checkpoint</a>.
          This allows a developer to set up handlers
          in the <code>.then</code> handler of the result promise.
        </p>

        <p>
          The <code><dfn>stopNotifications</dfn>()</code> method, when invoked,
          MUST return <a>a new promise</a> <var>promise</var>
          and run the following steps <a>in parallel</a>:
        </p>
        <ol>
          <li>
            Let <var>characteristic</var> be
            the GATT <a>Characteristic</a> that <code>this</code> represents.
          </li>
          <li>
            If the <a>active notification context set</a> contains
            <a href="#idl-def-navigator-bluetooth"><code>navigator.bluetooth</code></a>,
            remove it.
          </li>
          <li>
            If the <a>active notification context set</a> became empty,
            the UA SHOULD use any of the <a>Characteristic Descriptors</a> procedures
            to clear the <code>Notification</code> and <code>Indication</code> bits in
            <var>characteristic</var>'s <a>Client Characteristic Configuration</a> descriptor.
          </li>
          <li>
            <a>Queue a task</a> to <a>resolve</a> <var>promise</var> with <code>undefined</code>.
          </li>
        </ol>

        <p class="note">
          Queuing a task to resolve the promise ensures that
          no <a href="#notification-events">value change events</a> due to notifications
          arrive after the promise resolves.
        </p>

        <section dfn-for="CharacteristicProperties">
          <h2><a>CharacteristicProperties</a></h2>

          <p>
            Each <a>BluetoothGATTCharacteristic</a> exposes its <a>characteristic properties</a>
            through a <a>CharacteristicProperties</a> object.
          </p>

          <pre class="idl">
            interface CharacteristicProperties {
              readonly attribute boolean broadcast;
              readonly attribute boolean read;
              readonly attribute boolean writeWithoutResponse;
              readonly attribute boolean write;
              readonly attribute boolean notify;
              readonly attribute boolean indicate;
              readonly attribute boolean authenticatedSignedWrites;
              readonly attribute boolean reliableWrite;
              readonly attribute boolean writableAuxiliaries;
            };
          </pre>

          <p>
            To <dfn>create a <code>CharacteristicProperties</code> instance
            from the Characteristic</dfn> <var>characteristic</var>,
            the UA MUST return <a>a new promise</a> <var>promise</var>
            and run the following steps <a>in parallel</a>:
          </p>
          <ol>
            <li>
              Let <var>propertiesObj</var> be a new instance of <a>CharacteristicProperties</a>.
            </li>
            <li>
              Let <var>properties</var> be
              the <a>characteristic properties</a> of <var>characteristic</var>.
            </li>
            <li>
              Initialize the attributes of <var>propertiesObj</var> from
              the corresponding bits in <var>properties</var>:
              <table>
                <tr><th>Attribute</th><th>Bit</th></tr>
                <tr><td><code>broadcast</code></td><td>Broadcast</td></tr>
                <tr><td><code>read</code></td><td>Read</td></tr>
                <tr><td><code>writeWithoutResponse</code></td><td>Write Without Response</td></tr>
                <tr><td><code>write</code></td><td>Write</td></tr>
                <tr><td><code>notify</code></td><td>Notify</td></tr>
                <tr><td><code>indicate</code></td><td>Indicate</td></tr>
                <tr>
                  <td><code>authenticatedSignedWrites</code></td>
                  <td>Authenticated Signed Writes</td>
                </tr>
              </table>
            </li>
            <li>
              If the Extended Properties bit of the <a>characteristic properties</a> is not set,
              initialize <code><var>propertiesObj</var>.reliableWrite</code> and
              <code><var>propertiesObj</var>.writableAuxiliaries</code> to <code>false</code>.
              Otherwise, run the following steps:
              <ol>
                <li>
                  <a title="Characteristic Descriptor Discovery">Discover</a> the
                  <a>Characteristic Extended Properties</a> descriptor for <var>characteristic</var>
                  and <a title="Read Characteristic Descriptors">read its value</a>
                  into <var>extendedProperties</var>.
                  Handle errors as described in <a href="#error-handling"></a>.
                  <p class="issue">
                    <a>Characteristic Extended Properties</a> isn't clear whether
                    the extended properties are immutable for a given Characteristic.
                    If they are, the UA should be allowed to cache them.
                  </p>
                </li>
                <li>
                  If the previous step returned an error,
                  <a>reject</a> <var>promise</var> with that error and abort these steps.
                </li>
                <li>
                  Initialize <code><var>propertiesObj</var>.reliableWrite</code> from
                  the Reliable Write bit of <var>extendedProperties</var>.
                </li>
                <li>
                  Initialize <code><var>propertiesObj</var>.writableAuxiliaries</code> from
                  the Writable Auxiliaries bit of <var>extendedProperties</var>.
                </li>
              </ol>
            </li>
            <li>
              <a>Resolve</a> <var>promise</var> with <var>propertiesObj</var>.
            </li>
          </ol>
        </section>
      </section>

      <section dfn-for="BluetoothGATTDescriptor">
        <h2><a>BluetoothGATTDescriptor</a></h2>

        <p><a>BluetoothGATTDescriptor</a> represents a GATT <a>Descriptor</a>, which provides further information about a <a>Characteristic</a>'s value.</p>

        <pre class="idl">
          interface BluetoothGATTDescriptor {
            readonly attribute UUID uuid;
            readonly attribute BluetoothGATTCharacteristic characteristic;
            readonly attribute DOMString instanceID;
            readonly attribute ArrayBuffer? value;
            Promise&lt;ArrayBuffer> readValue();
            Promise&lt;void> writeValue(ArrayBuffer value);
          };
        </pre>

        <div class="note" title="BluetoothGATTDescriptor attributes">
          <p>
            <dfn>uuid</dfn> is the UUID of the characteristic descriptor,
            e.g. <code>'00002902-0000-1000-8000-00805f9b34fb'</code> for the
            <a href="https://developer.bluetooth.org/gatt/descriptors/Pages/DescriptorViewer.aspx?u=org.bluetooth.descriptor.gatt.client_characteristic_configuration.xml"
               >Client Characteristic Configuration</a> descriptor.
          </p>
          <p>
            <dfn>characteristic</dfn> is the GATT characteristic this descriptor belongs to.
          </p>
          <p>
            <dfn>instanceID</dfn> is the opaque identifier assigned to this descriptor,
            which can be used distinguish between
            multiple descriptors with the same UUID in a single characteristic.
            It is computed by the <a>get an attribute id</a> algorithm.
          </p>

          <p>
            <dfn>value</dfn> is the currently cached descriptor value.
            This value gets updated when the value of the descriptor is read.
          </p>
        </div>

        <p>
          To <dfn>create a <code>BluetoothGATTDescriptor</code> representing</dfn>
          a Descriptor <var>descriptor</var>,
          the UA must return <a>a new promise</a> <var>promise</var>
          and run the following steps <a>in parallel</a>.
        </p>
        <ol>
          <li>Let <var>result</var> be a new instance of <a>BluetoothGATTDescriptor</a>.</li>
          <li>
            Initialize <code><var>result</var>.uuid</code> from the UUID of <var>descriptor</var>.
          </li>
          <li>
            Initialize <code><var>result</var>.characteristic</code> from
            the <a>BluetoothGATTCharacteristic</a> instance representing
            the Characteristic in which <var>descriptor</var> appears.
          </li>
          <li>
            <a>Get an attribute id</a> for <var>descriptor</var>,
            and initialize <code><var>result</var>.instanceID</code> to the result.
          </li>
          <li>
            Initialize <code><var>result</var>.value</code> to <code>null</code>.
            The UA MAY initialize <code><var>result</var>.value</code> to
            a new <code>ArrayBuffer</code> containing
            the most recently read value from <var>descriptor</var>
            if this value is available.
          </li>
          <li><a>Resolve</a> <var>promise</var> with <var>result</var>.</li>
        </ol>

        <p>
          The <code><dfn>readValue</dfn>()</code> method, when invoked,
          MUST retrieve the value of this descriptor from a remote peripheral.
          Updates the descriptor's <code>value</code> field to hold the result of the read request and resolves the promise with the same <a>ArrayBuffer</a>.
        </p>

        <p>
          The <code><dfn>writeValue</dfn>(<var>value</var>)</code> method, when invoked,
          MUST write <code><var>value</var></code> to this characteristic descriptor on the remote peripheral.
        </p>
      </section>

      <section dfn-for="Bluetooth" id="object-and-uuid-lookup">
        <h2>Object and UUID lookup on <code>navigator.bluetooth</code></h2>

        <pre class="idl">
          partial interface Bluetooth {
            readonly attribute BluetoothUUIDs uuids;
            Promise&lt;BluetoothGATTService>
              getService(DOMString serviceInstanceID);
            Promise&lt;BluetoothGATTCharacteristic>
              getCharacteristic(DOMString characteristicInstanceID);
            Promise&lt;BluetoothGATTDescriptor>
              getDescriptor(DOMString descriptorInstanceID);
          };
          Bluetooth implements ServiceEventHandlers;
        </pre>

        <p>
          The <code><dfn>getService</dfn>(<var>serviceInstanceID</var>)</code> method, when invoked,
          MUST return the GATT service with an instance ID of
          <code><var>serviceInstanceID</var></code>.
        </p>
        <p>
          The <code><dfn>getCharacteristic</dfn>(<var>characteristicInstanceID</var>)</code> method, when invoked,
          MUST return the GATT characteristic with an instance ID of
          <code><var>characteristicInstanceID</var></code>.
        </p>
        <p>
          The <code><dfn>getDescriptor</dfn>(<var>descriptorInstanceID</var>)</code> method, when invoked,
          MUST return the GATT descriptor with an instance ID of
          <code><var>descriptorInstanceID</var></code>.
        </p>
      </section>

      <section>
        <h2>Events</h2>

        <section id="bluetooth-tree">
          <h2>Bluetooth Tree</h2>

          <p>
            <a href="#idl-def-navigator-bluetooth"><code>navigator.bluetooth</code></a> and
            objects implementing the <a>BluetoothDevice</a>, <a>BluetoothGATTService</a>,
            <a>BluetoothGATTCharacteristic</a>, or <a>BluetoothGATTDescriptor</a> interface
            <a>participate in a tree</a>,
            simply named the <dfn>Bluetooth tree</dfn>.

          <ul>
            <li>
              The <a>children</a>
              of <a href="#idl-def-navigator-bluetooth"><code>navigator.bluetooth</code></a>
              are the <a>BluetoothDevice</a> objects representing
              devices on the origin's <a>allowed devices map</a>,
              in an unspecified order.
            </li>
            <li>
              The <a>children</a> of a <a>BluetoothDevice</a>
              are the <a>BluetoothGATTService</a> objects representing
              Primary and Secondary <a>Service</a>s on its GATT <a>Server</a>
              whose UUIDs are on the origin and device's <a>allowed services list</a>.
              The order of the primary services MUST be consistent with the order returned by
              the <a>Discover Primary Service by Service UUID</a> procedure,
              but secondary services and primary services with different UUIDs may be in any order.
            </li>
            <li>
              The <a>children</a> of a <a>BluetoothGATTService</a> are
              the <a>BluetoothGATTCharacteristic</a> objects representing its Characteristics.
              The order of the characteristics MUST be consistent with the order returned by
              the <a>Discover Characteristics by UUID</a> procedure,
              but characteristics with different UUIDs may be in any order.
            </li>
            <li>
              The <a>children</a> of a <a>BluetoothGATTCharacteristic</a> are
              the <a>BluetoothGATTDescriptor</a> objects representing its Descriptors
              in the order returned by the <a>Discover All Characteristic Descriptors</a> procedure.
            </li>
          </ul>
        </section>

        <section id="event-types">
          <h2>Event types</h2>

          <dl>
            <dt><dfn><code>characteristicvaluechanged</code></dfn></dt>
            <dd>
              Fired on a <a>BluetoothGATTCharacteristic</a> when its value changes,
              either as a result of
              a <a for="BluetoothGATTCharacteristic" title="readValue">read request</a>,
              or a <a href="#notification-events">value change notification/indication</a>.
            </dd>

            <dt><dfn><code>serviceadded</code></dfn></dt>
            <dd>
              Fired on a new <a>BluetoothGATTService</a>
              <a href="#service-change-events">when it has been discovered on a remote device</a>,
              just after it is added to the <a>Bluetooth tree</a>.
            </dd>

            <dt><dfn><code>servicechanged</code></dfn></dt>
            <dd>
              Fired on a <a>BluetoothGATTService</a>
              <a href="#service-change-events">when its state changes</a>.
              This involves any characteristics and/or descriptors
              that get added or removed from the service,
              as well as <a>Service Changed</a> indications from the remote device.
            </dd>

            <dt><dfn><code>serviceremoved</code></dfn></dt>
            <dd>
              Fired on a <a>BluetoothGATTService</a>
              <a href="#service-change-events">when it has been removed from its device</a>,
              just before it is removed from the <a>Bluetooth tree</a>.
            </dd>

          </dl>
        </section>

        <section id="notification-events">
          <h2>Responding to Notifications and Indications</h2>

          <p>
            When the UA receives a Bluetooth <a>Characteristic Value Notification</a>
            or <a title="Characteristic Value Indications">Indication</a>,
            it must perform the following steps:

          <ol>
            <li>
              For each <var>bluetoothGlobal</var> in
              the <a>active notification context set</a> for the Characteristic,
              <a>queue a task</a>
              on the event loop of the script settings object of <var>bluetoothGlobal</var>
              to do the following steps:

              <ol>
                <li>
                  Let <var>characteristicObject</var> be the <a>BluetoothGATTCharacteristic</a> in
                  the <a>Bluetooth tree</a> rooted at <var>bluetoothGlobal</var>
                  that represents the <a>Characteristic</a>.
                </li>
                <li>
                  Set <code><var>characteristicObject</var>.value</code> to
                  a new <code>ArrayBuffer</code> holding the new value of the <a>Characteristic</a>.
                </li>
                <li>
                  <a>Fire an event</a> named <a><code>characteristicvaluechanged</code></a>
                  with its <code>bubbles</code> attribute initialized to <code>true</code>
                  at <var>characteristicObject</var>.
                </li>
              </ol>
            </li>
          </ol>
        </section>

        <section id="service-change-events">
          <h2>Responding to Service Changes</h2>

          <p>
            The Bluetooth <a>Attribute Caching</a> system allows clients
            to track changes to <a>Service</a>s, <a>Characteristic</a>s, and <a>Descriptor</a>s.
            Before discovering any of these entities for the purpose of exposing them to a web page
            the UA MUST subscribe to Indications from the
            <a>Service Changed</a> characteristic, if it exists.
            When the UA receives an Indication on the Service Changed characteristic,
            it MUST perform the following steps.

          <ol>
            <li>
              Let <var>removedEntities</var> be the list of entities in
              the range indicated by the Service Changed characteristic
              that the UA had discovered before the Indication.
            </li>
            <li>
              Use the <a>Primary Service Discovery</a>, <a>Relationship Discovery</a>, <a>Characteristic Discovery</a>,
              and <a>Characteristic Descriptor Discovery</a> procedures
              to re-discover entities in the range indicated by the Service Changed characteristic.
              The UA MAY skip discovering all or part of the indicated range
              if it can prove that the results of that discovery
              could not affect the events fired below.
            </li>
            <li>
              Let <var>addedEntities</var> be the list of entities discovered in the previous step.
            </li>
            <li>
              If an entity with the same definition, ignoring Characteristic and Descriptor values,
              appears in both <var>removedEntities</var> and <var>addedEntities</var>,
              remove it from both.
            </li>
            <li>
              Let <var>changedServices</var> be a set of <a>Service</a>s, initially empty.
            </li>
            <li>
              If the <a title="same attribute">same</a> <a>Service</a> appears in
              both <var>removedEntities</var> and <var>addedEntities</var>,
              remove it from both, and add it to <var>changedServices</var>.
            </li>
            <li>
              For each <a>Characteristic</a> and <a>Descriptor</a>
              in <var>removedEntities</var> and <var>addedEntities</var>,
              remove it from its original list,
              and add its parent <a>Service</a> to <var>changedServices</var>.
              <span class="note">After this point, <var>removedEntities</var> and <var>addedEntities</var> contain only <a>Service</a>s.</span>
            </li>
            <li>
              If a <a>Service</a> in <var>addedEntities</var>
              would not have been returned to any <a>script execution environment</a>
              if it had existed at the time of any previous call to
              <code>getPrimaryService</code>, <code>getPrimaryServices</code>,
              <code>getIncludedService</code>, or <code>getIncludedServices</code>,
              the UA MAY remove the <a>Service</a> from <var>addedEntities</var>.
            </li>
            <li>
              Let <var>changedDevices</var> be the set of <a>Bluetooth device</a>s that
              contain any <a>Service</a> in
              <var>removedEntities</var>, <var>addedEntities</var>, and <var>changedServices</var>.
            </li>
            <li>
              For each <a>script execution environment</a>
              that is connected to a device in <var>changedDevices</var>,
              <a>queue a task</a> on its event loop to do the following steps:
              <ol>
                <li>
                  For each <a>Service</a> in <var>removedEntities</var>,
                  <a>fire an event</a> named <a><code>serviceremoved</code></a>
                  with its <code>bubbles</code> attribute initialized to <code>true</code>
                  at the <a>BluetoothGATTService</a> representing the <a>Service</a>.
                  Then remove this <a>BluetoothGATTService</a> from the <a>Bluetooth tree</a>.
                </li>
                <li>
                  For each <a>Service</a> in <var>addedEntities</var>,
                  add the <a>BluetoothGATTService</a> representing this <a>Service</a> to the <a>Bluetooth tree</a>.
                  Then <a>fire an event</a> named <a><code>serviceadded</code></a>
                  with its <code>bubbles</code> attribute initialized to <code>true</code>
                  at the <a>BluetoothGATTService</a>.
                </li>
                <li>
                  For each <a>Service</a> in <var>changedServices</var>,
                  <a>fire an event</a> named <a><code>servicechanged</code></a>
                  with its <code>bubbles</code> attribute initialized to <code>true</code>
                  at the <a>BluetoothGATTService</a> representing the <a>Service</a>.
                </li>
              </ol>
            </li>
          </ol>
        </section>

        <section>
          <h2>IDL event handlers</h2>

          <pre class="idl">
            [NoInterfaceObject]
            interface CharacteristicEventHandlers : EventTarget {
              attribute EventHandler oncharacteristicvaluechanged;
            };
          </pre>
          <p>
            <dfn for="CharacteristicEventHandlers">oncharacteristicvaluechanged</dfn>
            is an <a>Event handler IDL attribute</a>
            for the <a><code>characteristicvaluechanged</code></a> event type.
          </p>

          <pre class="idl">
            [NoInterfaceObject]
            interface ServiceEventHandlers : CharacteristicEventHandlers {
              attribute EventHandler onserviceadded;
              attribute EventHandler onservicechanged;
              attribute EventHandler onserviceremoved;
            };
          </pre>
          <p>
            <dfn for="ServiceEventHandlers">onserviceadded</dfn>
            is an <a>Event handler IDL attribute</a>
            for the <a><code>serviceadded</code></a> event type.
          </p>
          <p>
            <dfn for="ServiceEventHandlers">onservicechanged</dfn>
            is an <a>Event handler IDL attribute</a>
            for the <a><code>servicechanged</code></a> event type.
          </p>
          <p>
            <dfn for="ServiceEventHandlers">onserviceremoved</dfn>
            is an <a>Event handler IDL attribute</a>
            for the <a><code>serviceremoved</code></a> event type.
          </p>
        </section>
      </section>

      <section id="error-handling">
        <h2>Error handling</h2>

        <p class="note">
          This section primarily defines the mapping from system errors to Javascript error names
          and allows UAs to retry certain operations.
          The retry logic and possible error distinctions
          are highly constrained by the operating system,
          so places these requirements don't reflect reality
          are likely <a href="https://github.com/WebBluetoothCG/web-bluetooth/issues">spec bugs</a>
          instead of browser bugs.
        </p>

        <p>
          When the UA is using a <a title="GATT procedures">GATT procedure</a>
          to execute a step in an algorithm or to handle a query to the <a>Bluetooth cache</a>
          (both referred to as a "step", here),
          and the GATT procedure returns an <code><a>Error Response</a></code>,
          the UA MUST perform the following steps:
        </p>

        <ol>
          <li>
            If the <a title="Procedure timeouts">procedure times out</a> or
            the ATT Bearer (described in <a>Profile Fundamentals</a>) is terminated for any reason,
            return a <a>NetworkError</a> from the step and abort these steps.
          </li>
          <li>
            Take the following actions depending on the <code>Error Code</code>:
            <dl>
              <dt><code>Invalid Handle</code></dt>
              <dt><code>Invalid PDU</code></dt>
              <dt><code>Invalid Offset</code></dt>
              <dt><code>Attribute Not Found</code></dt>
              <dt><code>Unsupported Group Type</code></dt>
              <dd>
                These error codes indicate that something unexpected happened at the protocol layer,
                likely either due to a UA or device bug.
                Return a <a>NotSupportedError</a> from the step.
              </dd>

              <dt><code>Invalid Attribute Value Length</code></dt>
              <dd>
                Return an <a>InvalidModificationError</a> from the step.
              </dd>

              <dt><code>Attribute Not Long</code></dt>
              <dd>
                <p>
                  If this error code is received without having used a "Long" sub-procedure,
                  this may indicate a device bug.
                  Return a <a>NotSupportedError</a> from the step.
                </p>

                <p>
                  Otherwise, retry the step without using a "Long" sub-procedure.
                  If this is impossible due to the length of the value being written,
                  return an <a>InvalidModificationError</a> from the step.
                </p>
              </dd>

              <dt><code>Insufficient Authentication</code></dt>
              <dt><code>Insufficient Encryption</code></dt>
              <dt><code>Insufficient Encryption Key Size</code></dt>
              <dd>
                The UA SHOULD attempt to increase the security level of the connection.
                If this attempt fails or the UA doesn't support any higher security,
                Return a <a>SecurityError</a> from the step.
                Otherwise, retry the step at the new higher security level.
              </dd>

              <dt><code>Insufficient Authorization</code></dt>
              <dd>
                Return a <a>SecurityError</a> from the step.
              </dd>

              <dt><code>Read Not Permitted</code></dt>
              <dt><code>Write Not Permitted</code></dt>
              <dt><code>Request Not Supported</code></dt>
              <dt><code>Prepare Queue Full</code></dt>
              <dt><code>Insufficient Resources</code></dt>
              <dt><code>Unlikely Error</code></dt>
              <dt>Anything else</dt>
              <dd>
                Return a <a>NotSupportedError</a> from the step.
              </dd>
            </dl>
          </li>
        </ol>
      </section>
    </section>

    <section>
      <h2>UUIDs</h2>

      <div title="typedef DOMString UUID" class="idl"></div>
      <p>
        A <a>UUID</a> string represents a 128-bit [[!RFC4122]] UUID.
        A <dfn>valid UUID</dfn> is a string that matches
        the [[!ECMAScript]] regexp
        <code>/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/</code>.
        That is, a <a>valid UUID</a> is lower-case and
        does not use the 16- or 32-bit abbreviations defined by the Bluetooth standard.
        All UUIDs returned from functions and attributes in this specification
        MUST be <a>valid UUID</a>s.
        If a function in this specification takes a parameter whose type is <a>UUID</a>
        or a dictionary including a <a>UUID</a> attribute,
        and the argument passed in any <a>UUID</a> slot is not a <a>valid UUID</a>,
        the function MUST return <a>a promise rejected with</a> a <code>TypeError</code>
        and abort its other steps.
      </p>
      <p class="note">
        This standard provides the
        <code><a for="BluetoothUUIDs">canonicalUUID</a>()</code> function
        to map a 16- or 32-bit Bluetooth <a>UUID alias</a> to its 128-bit form.
      </p>
      <p class="note">
        Bluetooth devices are required to convert 16- and 32-bit UUIDs to 128-bit UUIDs
        before comparing them (as described in <a>Attribute Type</a>), but not all devices do so.
        To interoperate with these devices,
        if the UA has received a UUID from the device in one form (16-, 32-, or 128-bit),
        it should send other aliases of that UUID back to the device in the same form.
      </p>
    </section>

    <section>
      <h2>Standardized identifiers</h2>

      <p>
        The Bluetooth standard defines numbers that identify services, characteristics, descriptors, and other entities.
        This section provides javascript names for these constants so they don't need to be replicated in each application.

      <pre class="idl">
        [NoInterfaceObject]
        interface BluetoothUUIDs {
          readonly attribute BluetoothUUIDsService service;
          readonly attribute BluetoothUUIDsCharacteristic characteristic;
          readonly attribute BluetoothUUIDsDescriptor descriptor;
          UUID canonicalUUID(unsigned long alias);
        };
      </pre>

      <p dfn-for="BluetoothUUIDs">
        The <code><dfn>canonicalUUID</dfn>(<var>alias</var>)</code> method, when invoked,
        MUST return <a>the 128-bit UUID represented</a>
        by the 16- or 32-bit UUID alias <var>alias</var>.
      </p>
      <p class="note">
        This algorithm consists of
        replacing the top 32 bits of "<code>00000000-0000-1000-8000-00805f9b34fb</code>"
        with the bits of the alias.
        For example, <code>canonicalUUID(0xDEADBEEF)</code> returns
        <code>"deadbeef-0000-1000-8000-00805f9b34fb"</code>.
      </p>

      <section>
        <h2>Standard GATT Services</h2>

        <p>Each standardized service listed in [[!BLUETOOTH-NUMBERS-SERVICES]] MUST be reflected into <code>navigator.bluetooth.uuids.service</code> under the name listed under "SpecificationType" with <code>org.bluetooth.service.</code> removed.
        </p>
        <pre class="idl">
          [NoInterfaceObject]
          interface BluetoothUUIDsService {
            readonly attribute UUID alert_notification;
            readonly attribute UUID battery_service;
            readonly attribute UUID blood_pressure;
            readonly attribute UUID current_time;
            readonly attribute UUID cycling_power;
            readonly attribute UUID cycling_speed_and_cadence;
            readonly attribute UUID device_information;
            readonly attribute UUID generic_access;
            readonly attribute UUID generic_attribute;
            readonly attribute UUID glucose;
            readonly attribute UUID health_thermometer;
            readonly attribute UUID heart_rate;
            readonly attribute UUID human_interface_device;
            readonly attribute UUID immediate_alert;
            readonly attribute UUID link_loss;
            readonly attribute UUID location_and_navigation;
            readonly attribute UUID next_dst_change;
            readonly attribute UUID phone_alert_status;
            readonly attribute UUID reference_time_update;
            readonly attribute UUID running_speed_and_cadence;
            readonly attribute UUID scan_parameters;
            readonly attribute UUID tx_power;
            readonly attribute UUID user_data;
          };
        </pre>

        <p>
          The <a>BluetoothServiceName</a> enumeration allows users to pass the standardized services by name instead of looking up their <a>UUID</a>s inside <code>navigator.bluetooth.uuids.service</code>.
          When used as a parameter to a function in this specification that accepts a <a>BluetoothServiceUUID</a> parameter,
          these enumeration values MUST be treated as equivalent to the <a>UUID</a> they refer to.
        </p>
        <pre class="idl">
          enum BluetoothServiceName {
            "alert_notification",
            "battery_service",
            "blood_pressure",
            "current_time",
            "cycling_power",
            "cycling_speed_and_cadence",
            "device_information",
            "generic_access",
            "generic_attribute",
            "glucose",
            "health_thermometer",
            "heart_rate",
            "human_interface_device",
            "immediate_alert",
            "link_loss",
            "location_and_navigation",
            "next_dst_change",
            "phone_alert_status",
            "reference_time_update",
            "running_speed_and_cadence",
            "scan_parameters",
            "tx_power",
            "user_data"
          };
          typedef (BluetoothServiceName or UUID) BluetoothServiceUUID;
        </pre>

        <p>
          Each item of <a>BluetoothServiceName</a>
          and each attribute of <a>BluetoothUUIDsService</a> refers to or has a UUID value,
          as defined in the following table:
        </p>
        <table dfn-for="BluetoothUUIDsService">
          <tr><th>Enum value or attribute name</th><th>Value</th></tr>
          <tr><td><dfn>alert_notification</dfn></td><td><code>canonicalUUID(0x1811)</code></td></tr>
          <tr><td><dfn>battery_service</dfn></td><td><code>canonicalUUID(0x180F)</code></td></tr>
          <tr><td><dfn>blood_pressure</dfn></td><td><code>canonicalUUID(0x1810)</code></td></tr>
          <tr><td><dfn>current_time</dfn></td><td><code>canonicalUUID(0x1805)</code></td></tr>
          <tr><td><dfn>cycling_power</dfn></td><td><code>canonicalUUID(0x1818)</code></td></tr>
          <tr><td><dfn>cycling_speed_and_cadence</dfn></td><td><code>canonicalUUID(0x1816)</code></td></tr>
          <tr><td><dfn>device_information</dfn></td><td><code>canonicalUUID(0x180A)</code></td></tr>
          <tr><td><dfn>generic_access</dfn></td><td><code>canonicalUUID(0x1800)</code></td></tr>
          <tr><td><dfn>generic_attribute</dfn></td><td><code>canonicalUUID(0x1801)</code></td></tr>
          <tr><td><dfn>glucose</dfn></td><td><code>canonicalUUID(0x1808)</code></td></tr>
          <tr><td><dfn>health_thermometer</dfn></td><td><code>canonicalUUID(0x1809)</code></td></tr>
          <tr><td><dfn>heart_rate</dfn></td><td><code>canonicalUUID(0x180D)</code></td></tr>
          <tr><td><dfn>human_interface_device</dfn></td><td><code>canonicalUUID(0x1812)</code></td></tr>
          <tr><td><dfn>immediate_alert</dfn></td><td><code>canonicalUUID(0x1802)</code></td></tr>
          <tr><td><dfn>link_loss</dfn></td><td><code>canonicalUUID(0x1803)</code></td></tr>
          <tr><td><dfn>location_and_navigation</dfn></td><td><code>canonicalUUID(0x1819)</code></td></tr>
          <tr><td><dfn>next_dst_change</dfn></td><td><code>canonicalUUID(0x1807)</code></td></tr>
          <tr><td><dfn>phone_alert_status</dfn></td><td><code>canonicalUUID(0x180E)</code></td></tr>
          <tr><td><dfn>reference_time_update</dfn></td><td><code>canonicalUUID(0x1806)</code></td></tr>
          <tr><td><dfn>running_speed_and_cadence</dfn></td><td><code>canonicalUUID(0x1814)</code></td></tr>
          <tr><td><dfn>scan_parameters</dfn></td><td><code>canonicalUUID(0x1813)</code></td></tr>
          <tr><td><dfn>tx_power</dfn></td><td><code>canonicalUUID(0x1804)</code></td></tr>
          <tr><td><dfn>user_data</dfn></td><td><code>canonicalUUID(0x181C)</code></td></tr>
        </table>
      </section>

      <section>
        <h2>Standard GATT Characteristics</h2>

        <p>Each standardized characteristic listed in [[!BLUETOOTH-NUMBERS-CHARACTERISTICS]] MUST be reflected into <code>navigator.bluetooth.uuids.characteristic</code> under the name listed under "SpecificationType" with <code>org.bluetooth.characteristic.</code> removed.
        </p>
        <pre class="idl">
          [NoInterfaceObject]
          interface BluetoothUUIDsCharacteristic {
            readonly attribute UUID aerobic_heart_rate_lower_limit;
            readonly attribute UUID aerobic_heart_rate_upper_limit;
            readonly attribute UUID aerobic_threshold;
            readonly attribute UUID age;
            readonly attribute UUID alert_category_id;
            readonly attribute UUID alert_category_id_bit_mask;
            readonly attribute UUID alert_level;
            readonly attribute UUID alert_notification_control_point;
            readonly attribute UUID alert_status;
            readonly attribute UUID anaerobic_heart_rate_lower_limit;
            readonly attribute UUID anaerobic_heart_rate_upper_limit;
            readonly attribute UUID anaerobic_threshold;
            readonly attribute UUID battery_level;
            readonly attribute UUID blood_pressure_feature;
            readonly attribute UUID blood_pressure_measurement;
            readonly attribute UUID body_sensor_location;
            readonly attribute UUID boot_keyboard_input_report;
            readonly attribute UUID boot_keyboard_output_report;
            readonly attribute UUID boot_mouse_input_report;
            readonly attribute UUID csc_feature;
            readonly attribute UUID csc_measurement;
            readonly attribute UUID current_time;
            readonly attribute UUID cycling_power_control_point;
            readonly attribute UUID cycling_power_feature;
            readonly attribute UUID cycling_power_measurement;
            readonly attribute UUID cycling_power_vector;
            readonly attribute UUID database_change_increment;
            readonly attribute UUID date_of_birth;
            readonly attribute UUID date_of_threshold_assessment;
            readonly attribute UUID date_time;
            readonly attribute UUID day_date_time;
            readonly attribute UUID day_of_week;
            readonly attribute UUID dst_offset;
            readonly attribute UUID email_address;
            readonly attribute UUID exact_time_256;
            readonly attribute UUID fat_burn_heart_rate_lower_limit;
            readonly attribute UUID fat_burn_heart_rate_upper_limit;
            readonly attribute UUID firmware_revision_string;
            readonly attribute UUID first_name;
            readonly attribute UUID five_zone_heart_rate_limits;
            readonly attribute BluetoothUUIDsCharacteristicGAP gap;
            readonly attribute BluetoothUUIDsCharacteristicGATT gatt;
            readonly attribute UUID gender;
            readonly attribute UUID glucose_feature;
            readonly attribute UUID glucose_measurement;
            readonly attribute UUID glucose_measurement_context;
            readonly attribute UUID hardware_revision_string;
            readonly attribute UUID heart_rate_control_point;
            readonly attribute UUID heart_rate_max;
            readonly attribute UUID heart_rate_measurement;
            readonly attribute UUID height;
            readonly attribute UUID hid_control_point;
            readonly attribute UUID hid_information;
            readonly attribute UUID hip_circumference;
            readonly attribute UUID ieee_11073_20601_regulatory_certification_data_list;
            readonly attribute UUID intermediate_blood_pressure;
            readonly attribute UUID intermediate_temperature;
            readonly attribute UUID language;
            readonly attribute UUID last_name;
            readonly attribute UUID ln_control_point;
            readonly attribute UUID ln_feature;
            readonly attribute UUID local_time_information;
            readonly attribute UUID location_and_speed;
            readonly attribute UUID manufacturer_name_string;
            readonly attribute UUID maximum_recommended_heart_rate;
            readonly attribute UUID measurement_interval;
            readonly attribute UUID model_number_string;
            readonly attribute UUID navigation;
            readonly attribute UUID new_alert;
            readonly attribute UUID pnp_id;
            readonly attribute UUID position_quality;
            readonly attribute UUID protocol_mode;
            readonly attribute UUID record_access_control_point;
            readonly attribute UUID reference_time_information;
            readonly attribute UUID report;
            readonly attribute UUID report_map;
            readonly attribute UUID resting_heart_rate;
            readonly attribute UUID ringer_control_point;
            readonly attribute UUID ringer_setting;
            readonly attribute UUID rsc_feature;
            readonly attribute UUID rsc_measurement;
            readonly attribute UUID sc_control_point;
            readonly attribute UUID scan_interval_window;
            readonly attribute UUID scan_refresh;
            readonly attribute UUID sensor_location;
            readonly attribute UUID serial_number_string;
            readonly attribute UUID software_revision_string;
            readonly attribute UUID sport_type_for_aerobic_and_anaerobic_thresholds;
            readonly attribute UUID supported_new_alert_category;
            readonly attribute UUID supported_unread_alert_category;
            readonly attribute UUID system_id;
            readonly attribute UUID temperature_measurement;
            readonly attribute UUID temperature_type;
            readonly attribute UUID three_zone_heart_rate_limits;
            readonly attribute UUID time_accuracy;
            readonly attribute UUID time_source;
          };

          [NoInterfaceObject]
          interface BluetoothUUIDsCharacteristicGAP {
            readonly attribute UUID appearance;
            readonly attribute UUID device_name;
            readonly attribute UUID peripheral_preferred_connection_parameters;
            readonly attribute UUID peripheral_privacy_flag;
            readonly attribute UUID reconnection_address;
          };
          [NoInterfaceObject]
          interface BluetoothUUIDsCharacteristicGATT {
            readonly attribute UUID service_changed;
          };
        </pre>

        <p>
          The <a>BluetoothCharacteristicName</a> enumeration allows users to pass the standardized characteristics by name instead of looking up their <a>UUID</a>s inside <code>navigator.bluetooth.uuids.characteristic</code>.
          When used as a parameter to a function in this specification that accepts a <a>BluetoothCharacteristicUUID</a> parameter,
          these enumeration values MUST be treated as equivalent to the <a>UUID</a> they refer to.
        </p>
        <pre class="idl">
          enum BluetoothCharacteristicName {
            "aerobic_heart_rate_lower_limit",
            "aerobic_heart_rate_upper_limit",
            "aerobic_threshold",
            "age",
            "alert_category_id",
            "alert_category_id_bit_mask",
            "alert_level",
            "alert_notification_control_point",
            "alert_status",
            "anaerobic_heart_rate_lower_limit",
            "anaerobic_heart_rate_upper_limit",
            "anaerobic_threshold",
            "gap.appearance",
            "battery_level",
            "blood_pressure_feature",
            "blood_pressure_measurement",
            "body_sensor_location",
            "boot_keyboard_input_report",
            "boot_keyboard_output_report",
            "boot_mouse_input_report",
            "csc_feature",
            "csc_measurement",
            "current_time",
            "cycling_power_control_point",
            "cycling_power_feature",
            "cycling_power_measurement",
            "cycling_power_vector",
            "database_change_increment",
            "date_of_birth",
            "date_of_threshold_assessment",
            "date_time",
            "day_date_time",
            "day_of_week",
            "gap.device_name",
            "dst_offset",
            "email_address",
            "exact_time_256",
            "fat_burn_heart_rate_lower_limit",
            "fat_burn_heart_rate_upper_limit",
            "firmware_revision_string",
            "first_name",
            "five_zone_heart_rate_limits",
            "gender",
            "glucose_feature",
            "glucose_measurement",
            "glucose_measurement_context",
            "hardware_revision_string",
            "heart_rate_control_point",
            "heart_rate_max",
            "heart_rate_measurement",
            "height",
            "hid_control_point",
            "hid_information",
            "hip_circumference",
            "ieee_11073_20601_regulatory_certification_data_list",
            "intermediate_blood_pressure",
            "intermediate_temperature",
            "language",
            "last_name",
            "ln_control_point",
            "ln_feature",
            "local_time_information",
            "location_and_speed",
            "manufacturer_name_string",
            "maximum_recommended_heart_rate",
            "measurement_interval",
            "model_number_string",
            "navigation",
            "new_alert",
            "gap.peripheral_preferred_connection_parameters",
            "gap.peripheral_privacy_flag",
            "pnp_id",
            "position_quality",
            "protocol_mode",
            "gap.reconnection_address",
            "record_access_control_point",
            "reference_time_information",
            "report",
            "report_map",
            "resting_heart_rate",
            "ringer_control_point",
            "ringer_setting",
            "rsc_feature",
            "rsc_measurement",
            "sc_control_point",
            "scan_interval_window",
            "scan_refresh",
            "sensor_location",
            "serial_number_string",
            "gatt.service_changed",
            "software_revision_string",
            "sport_type_for_aerobic_and_anaerobic_thresholds",
            "supported_new_alert_category",
            "supported_unread_alert_category",
            "system_id",
            "temperature_measurement",
            "temperature_type",
            "three_zone_heart_rate_limits",
            "time_accuracy",
            "time_source"
          };

          typedef (BluetoothCharacteristicName or UUID) BluetoothCharacteristicUUID;
        </pre>

        <p>
          Each item of <a>BluetoothCharacteristicName</a>
          and each attribute of <a>BluetoothUUIDsCharacteristic</a> refers to or has a UUID value,
          as defined in the following table:
        </p>
        <table dfn-for="BluetoothUUIDsCharacteristic">
          <tr><th>Enum value or attribute name</th><th>Value</th></tr>
          <tr><td><dfn>aerobic_heart_rate_lower_limit</dfn></td><td><code>canonicalUUID(0x2A7E)</code></td></tr>
          <tr><td><dfn>aerobic_heart_rate_upper_limit</dfn></td><td><code>canonicalUUID(0x2A84)</code></td></tr>
          <tr><td><dfn>aerobic_threshold</dfn></td><td><code>canonicalUUID(0x2A7F)</code></td></tr>
          <tr><td><dfn>age</dfn></td><td><code>canonicalUUID(0x2A80)</code></td></tr>
          <tr><td><dfn>alert_category_id</dfn></td><td><code>canonicalUUID(0x2A43)</code></td></tr>
          <tr><td><dfn>alert_category_id_bit_mask</dfn></td><td><code>canonicalUUID(0x2A42)</code></td></tr>
          <tr><td><dfn>alert_level</dfn></td><td><code>canonicalUUID(0x2A06)</code></td></tr>
          <tr><td><dfn>alert_notification_control_point</dfn></td><td><code>canonicalUUID(0x2A44)</code></td></tr>
          <tr><td><dfn>alert_status</dfn></td><td><code>canonicalUUID(0x2A3F)</code></td></tr>
          <tr><td><dfn>anaerobic_heart_rate_lower_limit</dfn></td><td><code>canonicalUUID(0x2A81)</code></td></tr>
          <tr><td><dfn>anaerobic_heart_rate_upper_limit</dfn></td><td><code>canonicalUUID(0x2A82)</code></td></tr>
          <tr><td><dfn>anaerobic_threshold</dfn></td><td><code>canonicalUUID(0x2A83)</code></td></tr>
          <tr><td><code>gap.<dfn for="BluetoothUUIDsCharacteristicGAP">appearance</dfn></code></td><td><code>canonicalUUID(0x2A01)</code></td></tr>
          <tr><td><dfn>battery_level</dfn></td><td><code>canonicalUUID(0x2A19)</code></td></tr>
          <tr><td><dfn>blood_pressure_feature</dfn></td><td><code>canonicalUUID(0x2A49)</code></td></tr>
          <tr><td><dfn>blood_pressure_measurement</dfn></td><td><code>canonicalUUID(0x2A35)</code></td></tr>
          <tr><td><dfn>body_sensor_location</dfn></td><td><code>canonicalUUID(0x2A38)</code></td></tr>
          <tr><td><dfn>boot_keyboard_input_report</dfn></td><td><code>canonicalUUID(0x2A22)</code></td></tr>
          <tr><td><dfn>boot_keyboard_output_report</dfn></td><td><code>canonicalUUID(0x2A32)</code></td></tr>
          <tr><td><dfn>boot_mouse_input_report</dfn></td><td><code>canonicalUUID(0x2A33)</code></td></tr>
          <tr><td><dfn>csc_feature</dfn></td><td><code>canonicalUUID(0x2A5C)</code></td></tr>
          <tr><td><dfn>csc_measurement</dfn></td><td><code>canonicalUUID(0x2A5B)</code></td></tr>
          <tr><td><dfn>current_time</dfn></td><td><code>canonicalUUID(0x2A2B)</code></td></tr>
          <tr><td><dfn>cycling_power_control_point</dfn></td><td><code>canonicalUUID(0x2A66)</code></td></tr>
          <tr><td><dfn>cycling_power_feature</dfn></td><td><code>canonicalUUID(0x2A65)</code></td></tr>
          <tr><td><dfn>cycling_power_measurement</dfn></td><td><code>canonicalUUID(0x2A63)</code></td></tr>
          <tr><td><dfn>cycling_power_vector</dfn></td><td><code>canonicalUUID(0x2A64)</code></td></tr>
          <tr><td><dfn>database_change_increment</dfn></td><td><code>canonicalUUID(0x2A99)</code></td></tr>
          <tr><td><dfn>date_of_birth</dfn></td><td><code>canonicalUUID(0x2A85)</code></td></tr>
          <tr><td><dfn>date_of_threshold_assessment</dfn></td><td><code>canonicalUUID(0x2A86)</code></td></tr>
          <tr><td><dfn>date_time</dfn></td><td><code>canonicalUUID(0x2A08)</code></td></tr>
          <tr><td><dfn>day_date_time</dfn></td><td><code>canonicalUUID(0x2A0A)</code></td></tr>
          <tr><td><dfn>day_of_week</dfn></td><td><code>canonicalUUID(0x2A09)</code></td></tr>
          <tr><td><code>gap.<dfn for="BluetoothUUIDsCharacteristicGAP">device_name</dfn></code></td><td><code>canonicalUUID(0x2A00)</code></td></tr>
          <tr><td><dfn>dst_offset</dfn></td><td><code>canonicalUUID(0x2A0D)</code></td></tr>
          <tr><td><dfn>email_address</dfn></td><td><code>canonicalUUID(0x2A87)</code></td></tr>
          <tr><td><dfn>exact_time_256</dfn></td><td><code>canonicalUUID(0x2A0C)</code></td></tr>
          <tr><td><dfn>fat_burn_heart_rate_lower_limit</dfn></td><td><code>canonicalUUID(0x2A88)</code></td></tr>
          <tr><td><dfn>fat_burn_heart_rate_upper_limit</dfn></td><td><code>canonicalUUID(0x2A89)</code></td></tr>
          <tr><td><dfn>firmware_revision_string</dfn></td><td><code>canonicalUUID(0x2A26)</code></td></tr>
          <tr><td><dfn>first_name</dfn></td><td><code>canonicalUUID(0x2A8A)</code></td></tr>
          <tr><td><dfn>five_zone_heart_rate_limits</dfn></td><td><code>canonicalUUID(0x2A8B)</code></td></tr>
          <tr><td><dfn>gender</dfn></td><td><code>canonicalUUID(0x2A8C)</code></td></tr>
          <tr><td><dfn>glucose_feature</dfn></td><td><code>canonicalUUID(0x2A51)</code></td></tr>
          <tr><td><dfn>glucose_measurement</dfn></td><td><code>canonicalUUID(0x2A18)</code></td></tr>
          <tr><td><dfn>glucose_measurement_context</dfn></td><td><code>canonicalUUID(0x2A34)</code></td></tr>
          <tr><td><dfn>hardware_revision_string</dfn></td><td><code>canonicalUUID(0x2A27)</code></td></tr>
          <tr><td><dfn>heart_rate_control_point</dfn></td><td><code>canonicalUUID(0x2A39)</code></td></tr>
          <tr><td><dfn>heart_rate_max</dfn></td><td><code>canonicalUUID(0x2A8D)</code></td></tr>
          <tr><td><dfn>heart_rate_measurement</dfn></td><td><code>canonicalUUID(0x2A37)</code></td></tr>
          <tr><td><dfn>height</dfn></td><td><code>canonicalUUID(0x2A8E)</code></td></tr>
          <tr><td><dfn>hid_control_point</dfn></td><td><code>canonicalUUID(0x2A4C)</code></td></tr>
          <tr><td><dfn>hid_information</dfn></td><td><code>canonicalUUID(0x2A4A)</code></td></tr>
          <tr><td><dfn>hip_circumference</dfn></td><td><code>canonicalUUID(0x2A8F)</code></td></tr>
          <tr><td><dfn>ieee_11073_20601_regulatory_certification_data_list</dfn></td><td><code>canonicalUUID(0x2A2A)</code></td></tr>
          <tr><td><dfn>intermediate_blood_pressure</dfn></td><td><code>canonicalUUID(0x2A36)</code></td></tr>
          <tr><td><dfn>intermediate_temperature</dfn></td><td><code>canonicalUUID(0x2A1E)</code></td></tr>
          <tr><td><dfn>language</dfn></td><td><code>canonicalUUID(0x2AA2)</code></td></tr>
          <tr><td><dfn>last_name</dfn></td><td><code>canonicalUUID(0x2A90)</code></td></tr>
          <tr><td><dfn>ln_control_point</dfn></td><td><code>canonicalUUID(0x2A6B)</code></td></tr>
          <tr><td><dfn>ln_feature</dfn></td><td><code>canonicalUUID(0x2A6A)</code></td></tr>
          <tr><td><dfn>local_time_information</dfn></td><td><code>canonicalUUID(0x2A0F)</code></td></tr>
          <tr><td><dfn>location_and_speed</dfn></td><td><code>canonicalUUID(0x2A67)</code></td></tr>
          <tr><td><dfn>manufacturer_name_string</dfn></td><td><code>canonicalUUID(0x2A29)</code></td></tr>
          <tr><td><dfn>maximum_recommended_heart_rate</dfn></td><td><code>canonicalUUID(0x2A91)</code></td></tr>
          <tr><td><dfn>measurement_interval</dfn></td><td><code>canonicalUUID(0x2A21)</code></td></tr>
          <tr><td><dfn>model_number_string</dfn></td><td><code>canonicalUUID(0x2A24)</code></td></tr>
          <tr><td><dfn>navigation</dfn></td><td><code>canonicalUUID(0x2A68)</code></td></tr>
          <tr><td><dfn>new_alert</dfn></td><td><code>canonicalUUID(0x2A46)</code></td></tr>
          <tr><td><code>gap.<dfn for="BluetoothUUIDsCharacteristicGAP">peripheral_preferred_connection_parameters</dfn></code></td><td><code>canonicalUUID(0x2A04)</code></td></tr>
          <tr><td><code>gap.<dfn for="BluetoothUUIDsCharacteristicGAP">peripheral_privacy_flag</dfn></code></td><td><code>canonicalUUID(0x2A02)</code></td></tr>
          <tr><td><dfn>pnp_id</dfn></td><td><code>canonicalUUID(0x2A50)</code></td></tr>
          <tr><td><dfn>position_quality</dfn></td><td><code>canonicalUUID(0x2A69)</code></td></tr>
          <tr><td><dfn>protocol_mode</dfn></td><td><code>canonicalUUID(0x2A4E)</code></td></tr>
          <tr><td><code>gap.<dfn for="BluetoothUUIDsCharacteristicGAP">reconnection_address</dfn></code></td><td><code>canonicalUUID(0x2A03)</code></td></tr>
          <tr><td><dfn>record_access_control_point</dfn></td><td><code>canonicalUUID(0x2A52)</code></td></tr>
          <tr><td><dfn>reference_time_information</dfn></td><td><code>canonicalUUID(0x2A14)</code></td></tr>
          <tr><td><dfn>report</dfn></td><td><code>canonicalUUID(0x2A4D)</code></td></tr>
          <tr><td><dfn>report_map</dfn></td><td><code>canonicalUUID(0x2A4B)</code></td></tr>
          <tr><td><dfn>resting_heart_rate</dfn></td><td><code>canonicalUUID(0x2A92)</code></td></tr>
          <tr><td><dfn>ringer_control_point</dfn></td><td><code>canonicalUUID(0x2A40)</code></td></tr>
          <tr><td><dfn>ringer_setting</dfn></td><td><code>canonicalUUID(0x2A41)</code></td></tr>
          <tr><td><dfn>rsc_feature</dfn></td><td><code>canonicalUUID(0x2A54)</code></td></tr>
          <tr><td><dfn>rsc_measurement</dfn></td><td><code>canonicalUUID(0x2A53)</code></td></tr>
          <tr><td><dfn>sc_control_point</dfn></td><td><code>canonicalUUID(0x2A55)</code></td></tr>
          <tr><td><dfn>scan_interval_window</dfn></td><td><code>canonicalUUID(0x2A4F)</code></td></tr>
          <tr><td><dfn>scan_refresh</dfn></td><td><code>canonicalUUID(0x2A31)</code></td></tr>
          <tr><td><dfn>sensor_location</dfn></td><td><code>canonicalUUID(0x2A5D)</code></td></tr>
          <tr><td><dfn>serial_number_string</dfn></td><td><code>canonicalUUID(0x2A25)</code></td></tr>
          <tr><td><code>gatt.<dfn for="BluetoothUUIDsCharacteristicGATT">service_changed</dfn></code></td><td><code>canonicalUUID(0x2A05)</code></td></tr>
          <tr><td><dfn>software_revision_string</dfn></td><td><code>canonicalUUID(0x2A28)</code></td></tr>
          <tr><td><dfn>sport_type_for_aerobic_and_anaerobic_thresholds</dfn></td><td><code>canonicalUUID(0x2A93)</code></td></tr>
          <tr><td><dfn>supported_new_alert_category</dfn></td><td><code>canonicalUUID(0x2A47)</code></td></tr>
          <tr><td><dfn>supported_unread_alert_category</dfn></td><td><code>canonicalUUID(0x2A48)</code></td></tr>
          <tr><td><dfn>system_id</dfn></td><td><code>canonicalUUID(0x2A23)</code></td></tr>
          <tr><td><dfn>temperature_measurement</dfn></td><td><code>canonicalUUID(0x2A1C)</code></td></tr>
          <tr><td><dfn>temperature_type</dfn></td><td><code>canonicalUUID(0x2A1D)</code></td></tr>
          <tr><td><dfn>three_zone_heart_rate_limits</dfn></td><td><code>canonicalUUID(0x2A94)</code></td></tr>
          <tr><td><dfn>time_accuracy</dfn></td><td><code>canonicalUUID(0x2A12)</code></td></tr>
          <tr><td><dfn>time_source</dfn></td><td><code>canonicalUUID(0x2A13)</code></td></tr>
        </table>
      </section>

      <section>
        <h2>Standard GATT Descriptors</h2>

        <p>Each standardized descriptor listed in [[!BLUETOOTH-NUMBERS-DESCRIPTORS]] MUST be reflected into <code>navigator.bluetooth.uuids.descriptor</code> under the name listed under "SpecificationType" with <code>org.bluetooth.descriptor.</code> removed.

        <pre class="idl">
          [NoInterfaceObject] interface BluetoothUUIDsDescriptor {
            readonly attribute BluetoothUUIDsDescriptorGATT gatt;
            readonly attribute UUID valid_range;
            readonly attribute UUID external_report_reference;
            readonly attribute UUID report_reference;
          };
          [NoInterfaceObject] interface BluetoothUUIDsDescriptorGATT {
            readonly attribute UUID characteristic_extended_properties;
            readonly attribute UUID characteristic_user_description;
            readonly attribute UUID client_characteristic_configuration;
            readonly attribute UUID server_characteristic_configuration;
            readonly attribute UUID characteristic_presentation_format;
            readonly attribute UUID characteristic_aggregate_format;
          };
        </pre>

        <p>
          The <a>BluetoothDescriptorName</a> enumeration allows users to pass the standardized descriptors by name instead of looking up their <a>UUID</a>s inside <code>navigator.bluetooth.uuids.descriptor</code>.
          When used as a parameter to a function in this specification that accepts a <a>BluetoothDescriptorUUID</a> parameter,
          these enumeration values MUST be treated as equivalent to the <a>UUID</a> they refer to.

        <pre class="idl">
          enum BluetoothDescriptorName {
            "gatt.characteristic_extended_properties",
            "gatt.characteristic_user_description",
            "gatt.client_characteristic_configuration",
            "gatt.server_characteristic_configuration",
            "gatt.characteristic_presentation_format",
            "gatt.characteristic_aggregate_format",
            "valid_range",
            "external_report_reference",
            "report_reference"
          };

          typedef (BluetoothDescriptorName or UUID) BluetoothDescriptorUUID;
        </pre>

        <table dfn-for="BluetoothUUIDsDescriptor">
          <tr><th>Enum value or attribute name</th><th>Value</th></tr>
          <tr><td><code>gatt.<dfn for="BluetoothUUIDsDescriptorGATT">characteristic_extended_properties</dfn></code></td><td><code>canonicalUUID(0x2900)</code></td></tr>
          <tr><td><code>gatt.<dfn for="BluetoothUUIDsDescriptorGATT">characteristic_user_description</dfn></code></td><td><code>canonicalUUID(0x2901)</code></td></tr>
          <tr><td><code>gatt.<dfn for="BluetoothUUIDsDescriptorGATT">client_characteristic_configuration</dfn></code></td><td><code>canonicalUUID(0x2902)</code></td></tr>
          <tr><td><code>gatt.<dfn for="BluetoothUUIDsDescriptorGATT">server_characteristic_configuration</dfn></code></td><td><code>canonicalUUID(0x2903)</code></td></tr>
          <tr><td><code>gatt.<dfn for="BluetoothUUIDsDescriptorGATT">characteristic_presentation_format</dfn></code></td><td><code>canonicalUUID(0x2904)</code></td></tr>
          <tr><td><code>gatt.<dfn for="BluetoothUUIDsDescriptorGATT">characteristic_aggregate_format</dfn></code></td><td><code>canonicalUUID(0x2905)</code></td></tr>
          <tr><td><dfn>valid_range</dfn></td><td><code>canonicalUUID(0x2906)</code></td></tr>
          <tr><td><dfn>external_report_reference</dfn></td><td><code>canonicalUUID(0x2907)</code></td></tr>
          <tr><td><dfn>report_reference</dfn></td><td><code>canonicalUUID(0x2908)</code></td></tr>
        </table>
      </section>
    </section>

    <section>
      <h2>Extensions to the Navigator Interface</h2>

      <pre class="idl">
        partial interface Navigator {
          readonly attribute Bluetooth bluetooth;
        };
      </pre>

      <p>
        The primary interface to the Bluetooth system is <code>navigator.bluetooth</code>.
      </p>
    </section>

    <section>
      <h2>Terminology and Conventions</h2>

      <p>
        This specification uses a few conventions and several terms from other specifications.
        This section lists those and links to their primary definitions.
      </p>

      <p>
        Inspired by
        the <a href="https://streams.spec.whatwg.org/#conventions">Streams specification</a>,
        we use the notation x@[[\y]] to refer to
        <a href="http://people.mozilla.org/~jorendorff/es6-draft.html#sec-object-internal-methods-and-internal-slots"
           >internal slots</a> of an object, instead of saying "the [[\y]] internal slot of x."
      </p>

      <p>
        This specification uses a few read-only types
        that are similar to WebIDL's <a>read only Array</a>.
      </p>
      <ul>
        <li>
          A <dfn>read only Map</dfn> has <a>Map</a>'s values and interface,
          except the <code>clear</code>, <code>delete</code>, and <code>set</code> methods
          are omitted.
        </li>
        <li>
          A <dfn>read only ArrayBuffer</dfn> has <a>ArrayBuffer</a>'s values and interface,
          except that attempting to write to its contents or transfer it
          has the same effect as trying to write to a <a>read only Array</a>'s contents.
          This applies to <a>TypedArray</a>s and <a>DataView</a>s
          wrapped around the <a>ArrayBuffer</a> too.
        </li>
      </p>

      <dl>
        <dt>[[!BLUETOOTH42]]</dt>
        <dd>
          <ol>
            <li value="1">Architecture &amp; Terminology Overview
              <ol type="A">
                <li value="1">Architecture
                  <ol>
                    <li value="4">Communication Topology and Operation
                      <ol>
                        <li value="2">Operational Procedures and Modes
                          <ol>
                            <li value="1">BR/EDR Procedures
                              <ol>
                                <li value="1">Inquiry (Discovering) Procedure
                                  <ol>
                                    <li value="1"><dfn>Extended Inquiry Response</dfn></li>
                                  </ol>
                                </li>
                              </ol>
                            </li>
                          </ol>
                        </li>
                      </ol>
                    </li>
                  </ol>
                </li>
              </ol>
            </li>
            <li value="2">Core System Package [BR/EDR Controller volume]
              <ol type="A">
                <li value="5">Host Controller Interface Functional Specification
                  <ol>
                    <li value="7">HCI Commands and Events
                      <ol>
                        <li value="4">Informational Parameters
                          <ol>
                            <li value="6"><dfn>Read BD_ADDR Command</dfn></li>
                          </ol>
                        </li>
                        <li value="5">Status Parameters
                          <ol>
                            <li value="4">
                              Read <dfn><abbr title="Received Signal Strength Indication"
                                              >RSSI</abbr></dfn> Command
                            </li>
                          </ol>
                        </li>
                      </ol>
                    </li>
                  </ol>
                </li>
              </ol>
            </li>
            <li value="3">Core System Package [Host volume]
              <ol type="A">
                <li value="2">Service Discovery Protocol (SDP) Specification
                  <ol>
                    <li value="2">Overview
                      <ol>
                        <li value="5"><dfn>Searching for Services</dfn>
                          <ol>
                            <li value="1">UUID
                              (defines <dfn>UUID alias</dfn>es and
                              the algorithm to compute <dfn>the 128-bit UUID represented</dfn>
                              by a UUID alias)
                            </li>
                          </ol>
                        </li>
                      </ol>
                    </li>
                  </ol>
                </li>
                <li value="3">Generic Access Profile
                  <ol>
                    <li value="3">User Interface Aspects
                      <ol>
                        <li value="2">Representation of Bluetooth Parameters
                          <ol>
                            <li value="2"><dfn>Bluetooth Device Name</dfn> (the user-friendly name)
                            </li>
                            <li value="4"><dfn>Class of Device</dfn></li>
                          </ol>
                        </li>
                      </ol>
                    </li>
                    <li value="6">Idle Mode Procedures &mdash; BR/EDR Physical Transport
                      <ol>
                        <li value="4"><dfn>Device Discovery</dfn></li>
                      </ol>
                    </li>
                    <li value="9">Operational Modes and Procedures &mdash; LE Physical Transport
                      <ol>
                        <li value="1">Broadcast Mode and Observation Procedure
                          <ol>
                            <li value="2"><dfn>Observation Procedure</dfn></li>
                          </ol>
                        </li>
                        <li value="2">Discovery Modes and Procedures
                          <ol>
                            <li value="6"><dfn>General Discovery Procedure</dfn></li>
                            <li value="7"><dfn>Name Discovery Procedure</dfn></li>
                          </ol>
                        </li>
                        <li value="3"><dfn>Connection Modes and Procedures</dfn></li>
                        <li value="4">Bonding Modes and Procedures
                          <ol>
                            <li value="4"><dfn>Bonding Procedure</dfn></li>
                          </ol>
                        </li>
                      </ol>
                    </li>
                    <li value="10">Security Aspects &mdash; LE Physical Transport
                      <ol>
                        <li value="7"><dfn>Privacy Feature</dfn></li>
                        <li value="8">Random Device Address
                          <ol>
                            <li value="1"><dfn>Static Address</dfn></li>
                            <li value="2"><dfn>Private address</dfn>
                              <ol>
                                <li value="3">
                                  <dfn>Resolvable Private Address Resolution Procedure</dfn>
                                </li>
                              </ol>
                            </li>
                          </ol>
                        </li>
                      </ol>
                    </li>
                    <li value="11"><dfn>Advertising Data</dfn> and Scan Response Data Format</li>
                    <li value="15">Bluetooth Device Requirements
                      <ol>
                        <li value="1">Bluetooth Device Address (defines <dfn>BD_ADDR</dfn>)
                          <ol>
                            <li value="1">Bluetooth Device Address Types
                              <ol>
                                <li value="1"><dfn>Public Bluetooth Address</dfn></li>
                              </ol>
                            </li>
                          </ol>
                        </li>
                      </ol>
                    </li>
                  </ol>
                </li>
                <li value="6">Attribute Protocol (ATT)
                  <ol>
                    <li value="3">Protocol Requirements
                      <ol>
                        <li value="2">Basic Concepts
                          <ol>
                            <li value="1"><dfn>Attribute Type</dfn></li>
                            <li value="2"><dfn>Attribute Handle</dfn></li>
                          </ol>
                        </li>
                        <li value="4">Attribute Protocol Pdus
                          <ol>
                            <li value="1">Error Handling
                              <ol>
                                <li value="1"><dfn>Error Response</dfn></li>
                              </ol>
                            </li>
                          </ol>
                        </li>
                      </ol>
                    </li>
                  </ol>
                </li>
                <li value="7">Generic Attribute Profile (GATT)
                  <ol>
                    <li value="2">Profile Overview
                      <ol>
                        <li value="4">
                          <dfn>Profile Fundamentals</dfn>,
                          defines the <dfn>ATT Bearer</dfn>
                        </li>
                        <li value="5">Attribute Protocol
                          <ol>
                            <li value="2"><dfn>Attribute Caching</dfn></li>
                          </ol>
                        </li>
                        <li value="6"><dfn>GATT Profile Hierarchy</dfn></li>
                      </ol>
                    </li>
                    <li value="3">Service Interoperability Requirements
                      <ol>
                        <li value="3">Characteristic Definition
                          <ol>
                            <li value="1">Characteristic Declaration
                              <ol>
                                <li value="1"><dfn>Characteristic Properties</dfn></li>
                              </ol>
                            </li>
                            <li value="3">Characteristic Descriptor Declarations
                              <ol>
                                <li value="1"><dfn>Characteristic Extended Properties</dfn></li>
                                <li value="3"><dfn>Client Characteristic Configuration</dfn></li>
                              </ol>
                            </li>
                          </ol>
                        </li>
                      </ol>
                    </li>
                    <li value="4">GATT Feature Requirements &mdash; defines the <dfn>GATT procedures</dfn>.
                      <ol>
                        <li value="4"><dfn>Primary Service Discovery</dfn>
                          <ol>
                            <li value="1"><dfn>Discover All Primary Services</dfn></li>
                            <li value="2"><dfn>Discover Primary Service by Service UUID</dfn></li>
                          </ol>
                        </li>
                        <li value="5"><dfn>Relationship Discovery</dfn>
                          <ol>
                            <li value="1"><dfn>Find Included Services</dfn></li>
                          </ol>
                        </li>
                        <li value="6"><dfn>Characteristic Discovery</dfn>
                          <ol>
                            <li value="1"><dfn>Discover All Characteristics of a Service</dfn></li>
                            <li value="2"><dfn>Discover Characteristics by UUID</dfn></li>
                          </ol>
                        </li>
                        <li value="7"><dfn>Characteristic Descriptor Discovery</dfn>
                          <ol>
                            <li value="1"><dfn>Discover All Characteristic Descriptors</dfn></li>
                          </ol>
                        </li>
                        <li value="8"><dfn>Characteristic Value Read</dfn></li>
                        <li value="10"><dfn>Characteristic Value Notification</dfn></li>
                        <li value="11"><dfn>Characteristic Value Indications</dfn></li>
                        <li value="12"><dfn>Characteristic Descriptors</dfn>
                          <ol value="1"><dfn>Read Characteristic Descriptors</dfn></ol>
                        </li>
                        <li value="14"><dfn>Procedure Timeouts</dfn></li>
                      </ol>
                    </li>
                    <li value="6"><dfn>GAP Interoperability Requirements</dfn>
                      <ol>
                        <li value="1">BR/EDR GAP Interoperability Requirements
                          <ol>
                            <li value="1">Connection Establishment</li>
                          </ol>
                        </li>
                        <li value="2">LE GAP Interoperability Requirements
                          <ol>
                            <li value="1">Connection Establishment</li>
                          </ol>
                        </li>
                      </ol>
                    </li>
                    <li value="7">Defined Generic Attribute Profile Service
                      <ol>
                        <li value="1"><dfn>Service Changed</dfn></li>
                      </ol>
                    </li>
                  </ol>
                </li>
                <li value="8">Security Manager Specification
                  <ol>
                    <li value="2">Security Manager
                      <ol>
                        <li value="4">Security in Bluetooth Low Energy
                          <ol>
                            <li value="1"><dfn>Definition of Keys and Values</dfn>,
                              defines the <dfn>Identity Resolving Key</dfn>
                              (<abbr title="Identity Resolving Key">IRK</abbr>)
                            </li>
                          </ol>
                        </li>
                      </ol>
                    </li>
                  </ol>
                </li>
              </ol>
            </li>
            <li value="6">Core System Package [Low Energy Controller volume]
              <ol type="A">
                <li value="2">Link Layer Specification
                  <ol>
                    <li value="1">General Description
                      <ol>
                        <li value="3">Device Address
                          <ol>
                            <li value="1"><dfn>Public Device Address</dfn></li>
                            <li value="2">Random Device Address
                              <ol>
                                <li value="1"><dfn>Static Device Address</dfn></li>
                              </ol>
                            </li>
                          </ol>
                        </li>
                      </ol>
                    </li>
                    <li value="4">Air Interface Protocol
                      <ol>
                        <li value="4">Non-Connected States
                          <ol>
                            <li value="3">Scanning State
                              <ol>
                                <li value="1"><dfn>Passive Scanning</dfn></li>
                              </ol>
                            </li>
                          </ol>
                        </li>
                      </ol>
                    </li>
                  </ol>
                </li>
              </ol>
            </li>
          </ol>
        </dd>
        <dt>[[!BLUETOOTH-ASSIGNED]]</dt>
        <dd>
          <ul>
            <li><a href="https://developer.bluetooth.org/gatt/characteristics/Pages/CharacteristicsHome.aspx"
                   >Characteristics</a>
              <ul>
                <li>
                  <a href="https://developer.bluetooth.org/gatt/characteristics/Pages/CharacteristicViewer.aspx?u=org.bluetooth.characteristic.gap.appearance.xml"
                     ><dfn>org.bluetooth.characteristic.gap.appearance</dfn></a>
                </li>
                <li>
                  <a href="https://developer.bluetooth.org/gatt/characteristics/Pages/CharacteristicViewer.aspx?u=org.bluetooth.characteristic.pnp_id.xml"
                     ><dfn>org.bluetooth.characteristic.pnp_id</dfn></a>
                </li>
              </ul>
            </li>
            <li><a href="https://developer.bluetooth.org/gatt/services/Pages/ServicesHome.aspx"
                   >Services</a>
              <ul>
                <li>
                  <a href="https://developer.bluetooth.org/gatt/services/Pages/ServiceViewer.aspx?u=org.bluetooth.service.device_information.xml"
                     ><dfn>org.bluetooth.service.device_information</dfn></a>
                </li>
              </ul>
            </li>
            <li>
              <a href="https://www.bluetooth.org/en-us/specification/assigned-numbers/generic-access-profile"
                 ><dfn>Shortened Local Name</dfn></a>
            </li>
          </ul>
        </dd>
        <dt>[[!BLUETOOTH-SUPPLEMENT5]]</dt>
        <dd>
          <ol type="A">
            <li value="1">Data Types Specification
              <ol>
                <li value="1">Data Types Definitions and Formats
                  <!-- The section names here are really general, so I've added
                       "Data Type" to some. -->
                  <ol>
                    <li value="1"><dfn>Service UUID Data Type</dfn></li>
                    <li value="2"><dfn>Local Name Data Type</dfn></li>
                    <li value="3"><dfn>Flags Data Type</dfn></li>
                    <li value="4"><dfn>Manufacturer Specific Data</dfn></li>
                    <li value="5"><dfn>TX Power Level</dfn></li>
                    <li value="11"><dfn>Service Data</dfn></li>
                    <li value="12"><dfn>Appearance</dfn></li>
                  </ol>
                </li>
              </ol>
            </li>
          </ol>
        </dd>
        <dt>[[!dom]]</dt>
        <dd>
          <ul>
            <li><a href="https://dom.spec.whatwg.org/#concept-tree-child"
                   ><dfn>children</dfn></a></li>
            <li><a href="https://dom.spec.whatwg.org/#concept-event-fire"
                   ><dfn>fire an event</dfn></a></li>
            <li><a href="https://dom.spec.whatwg.org/#concept-tree-participate"
                   ><dfn>participate in a tree</dfn></a></li>
            <li><a href="https://dom.spec.whatwg.org/#concept-tree"><dfn>tree</dfn></a></li>
          </ul>
        </dd>
        <dt>[[!ECMAScript]]</dt>
        <dd>
          <ul>
            <li><a href="http://people.mozilla.org/~jorendorff/es6-draft.html#sec-arraybuffer-constructor"
                   ><dfn><code>ArrayBuffer</code></dfn></a></li>
            <li><a href="http://people.mozilla.org/~jorendorff/es6-draft.html#sec-dataview-constructor"
                   ><dfn><code>DataView</code></dfn></a></li>
            <li><a href="http://people.mozilla.org/~jorendorff/es6-draft.html#sec-map-constructor"
                   ><dfn><code>Map</code></dfn></a></li>
            <li><a href="http://people.mozilla.org/~jorendorff/es6-draft.html#sec-promise-objects"><dfn>Promise</dfn></a></li>
            <li><a href="http://people.mozilla.org/~jorendorff/es6-draft.html#sec-typedarray-constructors"
                   ><dfn><code>TypedArray</code></dfn></a></li>
          </ul>
        </dd>
        <dt>[[!HTML]]</dt>
        <dd>
          <ul>
            <li><a href="https://html.spec.whatwg.org/multipage/browsers.html#allowed-to-show-a-popup"
                   ><dfn>allowed to show a popup</dfn></a></li>
            <li><a href="https://html.spec.whatwg.org/multipage/infrastructure.html#in-parallel"
                   ><dfn>in parallel</dfn></a></li>
            <li><a href="https://html.spec.whatwg.org/multipage/webappapis.html#incumbent-settings-object"
                   ><dfn>incumbent settings object</dfn></a></li>
            <li><a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-handler-idl-attributes"
                   ><dfn>Event handler IDL attribute</dfn></a></li>
            <li><a href="https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint"
                   ><dfn>perform a microtask checkpoint</dfn></a></li>
            <li><a href="https://html.spec.whatwg.org/multipage/webappapis.html#queue-a-task"
                   ><dfn>queue a task</dfn></a></li>
            <li><a href="https://html.spec.whatwg.org/multipage/webappapis.html#script-execution-environment"
                   ><dfn>script execution environment</dfn></a></li>
           </ul>
          </ul>
        </dd>
        <dt>[[!powerful-features]]</dt>
        <dd>
          <ul>
            <li><a href="https://w3c.github.io/webappsec/specs/powerfulfeatures/#sufficiently-secure-context"
                   ><dfn>sufficiently secure context</dfn></a></li>
          </ul>
        </dd>
        <dt>[[!WebIDL]]</dt>
        <dd>
          <ul>
            <li>Errors
              <ul>
                <li><a href="https://heycam.github.io/webidl/#aborterror"
                       ><dfn>AbortError</dfn></a></li>
                <li><a href="https://heycam.github.io/webidl/#invalidmodificationerror"
                       ><dfn>InvalidModificationError</dfn></a></li>
                <li><a href="https://heycam.github.io/webidl/#networkerror"
                       ><dfn>NetworkError</dfn></a></li>
                <li><a href="https://heycam.github.io/webidl/#notfounderror"
                       ><dfn>NotFoundError</dfn></a></li>
                <li><a href="https://heycam.github.io/webidl/#notsupportederror"
                       ><dfn>NotSupportedError</dfn></a></li>
                <li><a href="https://heycam.github.io/webidl/#securityerror"
                       ><dfn>SecurityError</dfn></a></li>
              </ul>
            </li>
            <li><a href="https://heycam.github.io/webidl/#dfn-read-only-array"
                   ><dfn>read only Array</dfn></a></li>
          </ul>
        </dd>
        <dt><a href="https://www.w3.org/2001/tag/doc/promises-guide"
               >Writing Promise-Using Specifications</a></dt>
        <dd>
          <ul>
            <li><a href="https://www.w3.org/2001/tag/doc/promises-guide#a-new-promise"
                   ><dfn>A new promise</dfn></a></li>
            <li><a href="http://www.w3.org/2001/tag/doc/promises-guide#a-promise-rejected-with"
                   ><dfn>A promise rejected with</dfn> ...</a></li>
            <li><a href="https://www.w3.org/2001/tag/doc/promises-guide#reject-promise"
                   ><dfn>Reject</dfn> a promise with ...</a></li>
            <li><a href="https://www.w3.org/2001/tag/doc/promises-guide#resolve-promise"
                   ><dfn>Resolve</dfn> a promise with ...</a></li>
            <li>
              <a href="https://www.w3.org/2001/tag/doc/promises-guide#transforming-by"
                 ><dfn>Transforming</dfn> a promise with a fulfillment and/or rejection handler</a>
            </li>
            <li>
              <a href="http://www.w3.org/2001/tag/doc/promises-guide#waiting-for-all"
                 ><dfn>Waiting for all</dfn> of a collection of promises</a>
            </li>
          </ul>
        </dd>
      </dl>
    </section>
  </body>
</html>
